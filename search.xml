<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[如何优雅的退出关闭重启gunicorn进程]]></title>
    <url>%2F2018%2F10%2F24%2F%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E9%80%80%E5%87%BA%E5%85%B3%E9%97%AD%E9%87%8D%E5%90%AFgunicorn%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[在工作中，会发现gunicorn启动的web服务，无论怎么使用kill -9 进程号都是无法杀死gunicorn，经过我一番百度和谷歌，发现想要删除gunicorn进程其实很简单。 1. 寻找masterpid通过执行如下命令，可以获取Gunicorn进程树： 1pstree -ap|grep gunicorn 得到如下的结果。 1234567891011121314151617181920212223242526|-grep,6194 --col gunicorn | `-gunicorn,30080 /usr/local/bin/gunicorn collect:app -c collect_gunicorn.py | |-gunicorn,4413 /usr/local/bin/gunicorn collect:app -c collect_gunicorn.py | |-gunicorn,8030 /usr/local/bin/gunicorn collect:app -c collect_gunicorn.py | |-gunicorn,8135 /usr/local/bin/gunicorn collect:app -c collect_gunicorn.py | |-gunicorn,8137 /usr/local/bin/gunicorn collect:app -c collect_gunicorn.py | |-gunicorn,11532 /usr/local/bin/gunicorn collect:app -c collect_gunicorn.py | |-gunicorn,13460 /usr/local/bin/gunicorn collect:app -c collect_gunicorn.py | |-gunicorn,19728 /usr/local/bin/gunicorn collect:app -c collect_gunicorn.py | |-gunicorn,23585 /usr/local/bin/gunicorn collect:app -c collect_gunicorn.py | |-gunicorn,23825 /usr/local/bin/gunicorn collect:app -c collect_gunicorn.py | |-gunicorn,27921 /usr/local/bin/gunicorn collect:app -c collect_gunicorn.py | |-gunicorn,28899 /usr/local/bin/gunicorn collect:app -c collect_gunicorn.py | |-gunicorn,28900 /usr/local/bin/gunicorn collect:app -c collect_gunicorn.py | |-gunicorn,28901 /usr/local/bin/gunicorn collect:app -c collect_gunicorn.py | |-gunicorn,35637 /usr/local/bin/gunicorn collect:app -c collect_gunicorn.py | |-gunicorn,36963 /usr/local/bin/gunicorn collect:app -c collect_gunicorn.py | |-gunicorn,43074 /usr/local/bin/gunicorn collect:app -c collect_gunicorn.py | |-gunicorn,43118 /usr/local/bin/gunicorn collect:app -c collect_gunicorn.py | |-gunicorn,43232 /usr/local/bin/gunicorn collect:app -c collect_gunicorn.py | |-gunicorn,43307 /usr/local/bin/gunicorn collect:app -c collect_gunicorn.py | |-gunicorn,43308 /usr/local/bin/gunicorn collect:app -c collect_gunicorn.py | |-gunicorn,44018 /usr/local/bin/gunicorn collect:app -c collect_gunicorn.py | |-gunicorn,46996 /usr/local/bin/gunicorn collect:app -c collect_gunicorn.py | |-gunicorn,47000 /usr/local/bin/gunicorn collect:app -c collect_gunicorn.py | `-gunicorn,47650 /usr/local/bin/gunicorn collect:app -c collect_gunicorn.py 很显然，30080就是Gunicorn的主进程。 2. 重启Gunicorn任务按照官方的推荐方法，很容易执行命令： 1kill -HUP 30080 执行上述命令后，再次执行“pstree -ap|grep gunicorn”，我们很容易发现，除了主进程，其他的Gunicorn进程都已经销毁，并新建了进程（进程ID发生了变化）。 3. 退出Gunicorn任务1kill -9 30080 转自:http://www.chenxm.cc/post/541.html?csdn]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>gunicorn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux每日命令(4)：pwd命令]]></title>
    <url>%2F2018%2F10%2F23%2Flinux%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4(4)%EF%BC%9Apwd%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Linux中用 pwd 命令来查看”当前工作目录“的完整路径。 简单得说，每当你在终端进行操作时，你都会有一个当前工作目录。 在不太确定当前位置时，就会使用pwd来判定当前目录在文件系统内的确切位置。 1．命令格式：pwd [参数] 2. 命令功能： pwd 代表的是‘Print Working Directory’（打印当前目录）。如它的名字那样，‘pwd’会打印出当前工作目录，或简单的来说就是当前用户所位于的目录。它会打印出以根目录 (/)为起点的完整目录名（绝对目录） 3. 常用参数：一般情况下不带任何参数 参数 描述 -L 即逻辑路径logical，当目录为连接路径时，显示连接路径 -P 即物理路径physical，显示实际物理路径，而非使用连接（link）路径 如果同时使用了‘-L‘和‘-P‘，‘-L‘会有更高的优先级。如果没有指定参数，pwd会避开所有的软链接，也就是说会使用‘-P‘参数。 4. 常用示例1. 查看pwd命令命令： man pwd 输出:123456789101112131415161718192021222324PWD(1) User Commands PWD(1)NAME pwd - print name of current/working directorySYNOPSIS pwd [OPTION]...DESCRIPTION Print the full filename of the current working directory. -L, --logical use PWD from environment, even if it contains symlinks -P, --physical avoid all symlinks --help display this help and exit --version output version information and exit If no option is specified, -P is assumed. Manual page pwd(1) line 1 (press h for help or q to quit) 2. 显示当前目录所在路径.命令： pwd 输出：12hc@hc-virtual-machine:~/PycharmProjects/py3_test$ pwd/home/hc/PycharmProjects/py3_test 目录结构如下：1234567891011121314151617181920212223242526272829hc@hc-virtual-machine:~/PycharmProjects$ tree -L 2.├── FreshOnline│ ├── apps│ ├── db_tools│ ├── extra_apps│ ├── FreshMartOnline│ ├── manage.py│ ├── media│ ├── README.md│ └── requirements.txt├── FreshOnline_env│ ├── bin│ ├── include│ ├── lib│ ├── lib64 -&gt; lib│ ├── pip-selfcheck.json│ ├── pyvenv.cfg│ └── share├── my_test│ ├── 2018.log│ ├── link2018 -&gt; 2018.log│ ├── ln2018│ └── test├── py3_test│ ├── t1.py│ └── venv└── test └── my_test -&gt; /home/hc/PycharmProjects/my_test 说明：目录为连接路径时，pwd -P 显示出实际路径，而非使用连接（link）路径；pwd显示的是连接路径 示例如下： PycharmProjects/test目录下有一个my_test连接文件,指向PycharmProjects/my_test目录,进入test目录下的my_test目录，使用pwd，显示结果与pwd -L 一致，是逻辑（连接）路径，要查看实际物理路径则使用pwd -P 1234567891011121314hc@hc-virtual-machine:~/PycharmProjects/test$ pwd/home/hc/PycharmProjects/testhc@hc-virtual-machine:~/PycharmProjects/test$ ll总用量 8drwxr-xr-x 2 hc hc 4096 10月 23 13:38 ./drwxrwxr-x 7 hc hc 4096 10月 23 13:30 ../lrwxrwxrwx 1 hc hc 32 10月 23 13:38 my_test -&gt; /home/hc/PycharmProjects/my_test/hc@hc-virtual-machine:~/PycharmProjects/test$ cd my_testhc@hc-virtual-machine:~/PycharmProjects/test/my_test$ pwd/home/hc/PycharmProjects/test/my_testhc@hc-virtual-machine:~/PycharmProjects/test/my_test$ pwd -P/home/hc/PycharmProjects/my_testhc@hc-virtual-machine:~/PycharmProjects/test/my_test$ pwd -L/home/hc/PycharmProjects/test/my_test 3. 多层连接文件时，显示所有连接文件最终指向的文件全路径 /root目录下面有个dir1目录，test连接文件指向dir1目录 /opt目录下面有一个test连接文件，指向/root/test连接文件 通过cd命令进入/opt/test pwd默认，只显示连接文件的全路径 123456789101112131415root@hc-virtual-machine:~# pwd/rootroot@hc-virtual-machine:~# ll total 12drwxr-xr-x 2 root root 4096 Apr 24 05:51 dir1lrwxrwxrwx 1 root root 5 Apr 24 05:54 test -&gt; dir1/root@hc-virtual-machine:~# ll /opt/ total 20drwx------ 16 sgl sgl 4096 Oct 17 2015 sgllrwxrwxrwx 1 root root 10 Apr 24 05:55 test -&gt; /root/testroot@hc-virtual-machine:~# cd /opt/test/ root@hc-virtual-machine:~# pwd /opt/testroot@hc-virtual-machine:~# pwd -P /root/dir1 pwd -P 显示连接文件最终指向的文件的全路径。注意这里不是/root/test。]]></content>
      <categories>
        <category>linux每日命令</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux每日命令(3)：ln命令]]></title>
    <url>%2F2018%2F10%2F23%2Flinux%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4(3)%EF%BC%9Aln%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[ln是linux中又一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接.当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。 1．命令格式：ln [参数][源文件或目录][目标文件或目录] 2．命令功能： Linux文件系统中，有所谓的链接(link)，我们可以将其视为档案的别名，而链接又可分为两种 : 硬链接(hard link)与软链接(symbolic link)，硬链接的意思是一个档案可以有多个名称，而软链接的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。硬链接是存在同一个文件系统中，而软链接却可以跨越不同的文件系统。 软链接： 软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式 软链接可以 跨文件系统 ，硬链接不可以 软链接可以对一个不存在的文件名进行链接 软链接可以对目录进行链接 软链接就相当于windows的的快捷方式，使用场景：1.在文件系统中多处共享同一个较大文件时，使用软链接就可以避免创建多个副本。2.维护动态库文件的版本时，使用软链接，在升级库文件后，只需修改软链接的源文件，而使用该库的程序则不需要修改。 使用原文件的绝对路径创建的软链接，不会随着软链接路径改动而失效！所以建议使用原文件绝对路径创建软链接。这时候的软链接才算得上是真正意义上相当于Windows的快捷方式，一旦生成处处可用 硬链接: 硬链接，以文件副本的形式存在。但不占用实际空间。 不允许给目录创建硬链接 硬链接只有在同一个文件系统中才能创建 硬链接说白了是一个指针，指向文件索引节点，系统并不为它重新分配inode。源文件和硬链接文件都是指向同一块磁盘空间的！通过使用硬链接可达到备份数据(实际是备份节点)的效果！ 注意：第一，ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化； 第二，ln的链接又分软链接和硬链接两种，软链接就是ln –s 源文件 目标文件，它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接 ln 源文件 目标文件，没有参数-s， 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。 ln指令用在链接文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则会把前面指定的所有文件或目录复制到该目录。若同时指定多个文件或目录，且最后的目的地并非是一个已存在的目录，则会出现错误信息。 3. 命令参数： 必要参数 描述 -b 删除，覆盖以前建立的链接 -d 允许超级用户制作目录的硬链接 -f 强制执行 -i 交互模式，文件存在则提示用户是否覆盖 -n 把符号链接视为一般目录 -s 软链接(符号链接) -v 显示详细的处理过程 选择参数 描述 -S “-S&lt;字尾备份字符串&gt; ”或 “–suffix=&lt;字尾备份字符串&gt;” -V “-V&lt;备份方式&gt;”或“–version-control=&lt;备份方式&gt;” –help 显示帮助信息 –version 显示版本信息 4. 常用示例1. 给2018.log创建一个名为link2018的软链接命令： ln -s 2018.log link2018 输出：123456789101112hc@hc-virtual-machine:~/PycharmProjects/my_test$ ls2018.loghc@hc-virtual-machine:~/PycharmProjects/my_test$ ln -s 2018.log link2018hc@hc-virtual-machine:~/PycharmProjects/my_test$ ls2018.log link2018hc@hc-virtual-machine:~/PycharmProjects/my_test$ ll总用量 12drwxrwxr-x 3 hc hc 4096 10月 23 11:53 ./drwxrwxr-x 6 hc hc 4096 10月 19 18:22 ../-rw-r--r-- 1 hc hc 0 10月 23 11:53 2018.logdrwxrwxr-x 2 hc hc 4096 10月 18 17:42 .idea/lrwxrwxrwx 1 hc hc 8 10月 23 11:53 link2018 -&gt; 2018.log 修改源文件2018.log内容，其软链接内容会同步修改123456789hc@hc-virtual-machine:~/PycharmProjects/my_test$ cat 2018.log 我是log日志hc@hc-virtual-machine:~/PycharmProjects/my_test$ cat link2018我是log日志hc@hc-virtual-machine:~/PycharmProjects/my_test$ vim 2018.log hc@hc-virtual-machine:~/PycharmProjects/my_test$ cat 2018.log 我是loghc@hc-virtual-machine:~/PycharmProjects/my_test$ cat link2018.log 我是log 说明： cat 命令是查看文件内容为2018.log文件创建软链接link2018，如果2018.log丢失，link2018将失效 2. 为2018.log 创建一个硬链接ln2018命令： ln 2018.log ln2018 输出：12345678910111213hc@hc-virtual-machine:~/PycharmProjects/my_test$ ls2018.log link2018hc@hc-virtual-machine:~/PycharmProjects/my_test$ ln 2018.log ln2018hc@hc-virtual-machine:~/PycharmProjects/my_test$ ls2018.log link2018 ln2018hc@hc-virtual-machine:~/PycharmProjects/my_test$ ll总用量 20drwxrwxr-x 3 hc hc 4096 10月 23 12:02 ./drwxrwxr-x 6 hc hc 4096 10月 19 18:22 ../-rw-r--r-- 2 hc hc 10 10月 23 11:57 2018.logdrwxrwxr-x 2 hc hc 4096 10月 18 17:42 .idea/lrwxrwxrwx 1 hc hc 8 10月 23 12:00 link2018 -&gt; 2018.log-rw-r--r-- 2 hc hc 10 10月 23 11:57 ln2018 说明： 为2018.log创建硬链接ln2018，2018.log与ln2018的各项属性相同 修改源文件2018.log内容，其软硬链接内容均会同步修改1234567891011hc@hc-virtual-machine:~/PycharmProjects/my_test$ cat ln2018 我是loghc@hc-virtual-machine:~/PycharmProjects/my_test$ cat 2018.log 我是loghc@hc-virtual-machine:~/PycharmProjects/my_test$ vim 2018.log hc@hc-virtual-machine:~/PycharmProjects/my_test$ cat 2018.log 我是log1hc@hc-virtual-machine:~/PycharmProjects/my_test$ cat ln2018 我是log1hc@hc-virtual-machine:~/PycharmProjects/my_test$ cat link2018 我是log1 3. 接上面两实例，链接完毕后，删除和重建链接原文件演示如下：1234567891011121314151617181920212223242526272829303132333435hc@hc-virtual-machine:~/PycharmProjects/my_test$ ls2018.log link2018 ln2018hc@hc-virtual-machine:~/PycharmProjects/my_test$ ll总用量 20drwxrwxr-x 3 hc hc 4096 10月 23 12:04 ./drwxrwxr-x 6 hc hc 4096 10月 19 18:22 ../-rw-r--r-- 2 hc hc 11 10月 23 12:04 2018.logdrwxrwxr-x 2 hc hc 4096 10月 18 17:42 .idea/lrwxrwxrwx 1 hc hc 8 10月 23 12:00 link2018 -&gt; 2018.log-rw-r--r-- 2 hc hc 11 10月 23 12:04 ln2018hc@hc-virtual-machine:~/PycharmProjects/my_test$ rm -rf 2018.log hc@hc-virtual-machine:~/PycharmProjects/my_test$ ll总用量 16drwxrwxr-x 3 hc hc 4096 10月 23 12:57 ./drwxrwxr-x 6 hc hc 4096 10月 19 18:22 ../drwxrwxr-x 2 hc hc 4096 10月 18 17:42 .idea/lrwxrwxrwx 1 hc hc 8 10月 23 12:00 link2018 -&gt; 2018.log-rw-r--r-- 1 hc hc 11 10月 23 12:04 ln2018hc@hc-virtual-machine:~/PycharmProjects/my_test$ touch 2018.loghc@hc-virtual-machine:~/PycharmProjects/my_test$ ll总用量 16drwxrwxr-x 3 hc hc 4096 10月 23 12:57 ./drwxrwxr-x 6 hc hc 4096 10月 19 18:22 ../-rw-r--r-- 1 hc hc 0 10月 23 12:57 2018.logdrwxrwxr-x 2 hc hc 4096 10月 18 17:42 .idea/lrwxrwxrwx 1 hc hc 8 10月 23 12:00 link2018 -&gt; 2018.log-rw-r--r-- 1 hc hc 11 10月 23 12:04 ln2018hc@hc-virtual-machine:~/PycharmProjects/my_test$ vim 2018.log hc@hc-virtual-machine:~/PycharmProjects/my_test$ cat 2018.log 2018log日志hc@hc-virtual-machine:~/PycharmProjects/my_test$ cat link2018 2018log日志hc@hc-virtual-machine:~/PycharmProjects/my_test$ cat ln2018 我是log1hc@hc-virtual-machine:~/PycharmProjects/my_test$ 说明： 源文件被删除后，并没有影响硬链接文件；软链接文件在centos系统下不断的闪烁，提示源文件已经不存在 重建源文件后，软链接不在闪烁提示，说明已经链接成功，找到了链接文件系统；重建后，硬链接文件并没有受到源文件影响，硬链接文件的内容还是保留了删除前源文件的内容，说明硬链接已经失效 4. 将文件链接到目录中演示如下：1234567891011121314151617181920212223242526272829hc@hc-virtual-machine:~/PycharmProjects/my_test$ ls2018.log link2018 ln2018hc@hc-virtual-machine:~/PycharmProjects/my_test$ mkdir testhc@hc-virtual-machine:~/PycharmProjects/my_test$ ls2018.log link2018 ln2018 testhc@hc-virtual-machine:~/PycharmProjects/my_test$ ln 2018.log testhc@hc-virtual-machine:~/PycharmProjects/my_test$ ls2018.log link2018 ln2018 testhc@hc-virtual-machine:~/PycharmProjects/my_test$ cd test/hc@hc-virtual-machine:~/PycharmProjects/my_test/test$ ls2018.loghc@hc-virtual-machine:~/PycharmProjects/my_test/test$ vi 2018.log hc@hc-virtual-machine:~/PycharmProjects/my_test/test$ cat 2018.log 2018log日志,加1hc@hc-virtual-machine:~/PycharmProjects/my_test/test$ cd ..hc@hc-virtual-machine:~/PycharmProjects/my_test$ ls2018.log link2018 ln2018 testhc@hc-virtual-machine:~/PycharmProjects/my_test$ cat 2018.log 2018log日志,加1hc@hc-virtual-machine:~/PycharmProjects/my_test$ ll总用量 24drwxrwxr-x 4 hc hc 4096 10月 23 13:31 ./drwxrwxr-x 7 hc hc 4096 10月 23 13:30 ../-rw-r--r-- 2 hc hc 19 10月 23 13:32 2018.logdrwxrwxr-x 2 hc hc 4096 10月 18 17:42 .idea/lrwxrwxrwx 1 hc hc 8 10月 23 12:00 link2018 -&gt; 2018.log-rw-r--r-- 1 hc hc 11 10月 23 12:04 ln2018drwxr-xr-x 2 hc hc 4096 10月 23 13:32 test/hc@hc-virtual-machine:~/PycharmProjects/my_test$ 说明： 在test目录中创建了2018.log的硬链接，修改test目录中的2018.log文件，同时也会同步到源文件 5：给目录创建软链接命令： ln -sv 源目录 目标目录 演示如下：12345678910111213141516171819202122232425262728293031323334353637383940hc@hc-virtual-machine:~/PycharmProjects$ ll总用量 28drwxrwxr-x 7 hc hc 4096 10月 23 13:30 ./drwxr-xr-x 23 hc hc 4096 10月 23 13:32 ../drwxr-xr-x 9 hc hc 4096 10月 22 15:25 FreshOnline/drwxrwxr-x 6 hc hc 4096 10月 19 19:07 FreshOnline_env/drwxrwxr-x 4 hc hc 4096 10月 23 13:31 my_test/drwxrwxr-x 4 hc hc 4096 10月 23 11:52 py3_test/drwxr-xr-x 2 hc hc 4096 10月 23 13:30 test/hc@hc-virtual-machine:~/PycharmProjects$ ln -sv /home/hc/PycharmProjects/my_test /home/hc/PycharmProjects/test'/home/hc/PycharmProjects/test/my_test' -&gt; '/home/hc/PycharmProjects/my_test'hc@hc-virtual-machine:~/PycharmProjects$ ll总用量 28drwxrwxr-x 7 hc hc 4096 10月 23 13:30 ./drwxr-xr-x 23 hc hc 4096 10月 23 13:32 ../drwxr-xr-x 9 hc hc 4096 10月 22 15:25 FreshOnline/drwxrwxr-x 6 hc hc 4096 10月 19 19:07 FreshOnline_env/drwxrwxr-x 4 hc hc 4096 10月 23 13:31 my_test/drwxrwxr-x 4 hc hc 4096 10月 23 11:52 py3_test/drwxr-xr-x 2 hc hc 4096 10月 23 13:38 test/hc@hc-virtual-machine:~/PycharmProjects$ cd my_test/hc@hc-virtual-machine:~/PycharmProjects/my_test$ ls2018.log link2018 ln2018 testhc@hc-virtual-machine:~/PycharmProjects/my_test$ cd ..hc@hc-virtual-machine:~/PycharmProjects$ lsFreshOnline FreshOnline_env my_test py3_test testhc@hc-virtual-machine:~/PycharmProjects$ cd test/hc@hc-virtual-machine:~/PycharmProjects/test$ lsmy_testhc@hc-virtual-machine:~/PycharmProjects/test$ cd my_testhc@hc-virtual-machine:~/PycharmProjects/test/my_test$ ls2018.log link2018 ln2018 testhc@hc-virtual-machine:~/PycharmProjects/test/my_test$ cd ..hc@hc-virtual-machine:~/PycharmProjects/test$ lsmy_testhc@hc-virtual-machine:~/PycharmProjects/test$ ll总用量 8drwxr-xr-x 2 hc hc 4096 10月 23 13:38 ./drwxrwxr-x 7 hc hc 4096 10月 23 13:30 ../lrwxrwxrwx 1 hc hc 32 10月 23 13:38 my_test -&gt; /home/hc/PycharmProjects/my_test/ 说明： 目录只能创建软链接 目录创建链接必须用绝对路径，相对路径创建会不成功，会提示：符号连接的层数过多 这样的错误 使用原文件的绝对路径创建的软链接，不会随着软链接路径改动而失效！所以建议使用原文件绝对路径创建软链接。这时候的软链接才算得上是真正意义上相当于Windows的快捷方式，一旦生成处处可用 在链接目标目录中修改文件都会在源文件目录中同步变化]]></content>
      <categories>
        <category>linux每日命令</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux每日命令(2)：cd命令]]></title>
    <url>%2F2018%2F10%2F22%2Flinux%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4(2)%EF%BC%9Acd%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1.命令格式：cd [目录名] 2.命令功能切换当前目录至 [目录名] 3. 常用范例1.进入系统根目录命令： cd / 说明：进入系统根目录,上面命令执行完后拿ls命令看一下，当前目录已经到系统根目录了 输出：1234567hc@hc-virtual-machine:~$ pwd/home/hchc@hc-virtual-machine:~$ cd /hc@hc-virtual-machine:/$ lsbin dev initrd.img lib64 mnt root snap sys varboot etc initrd.img.old lost+found opt run srv tmp vmlinuzcdrom home lib media proc sbin swapfile usr pwd的作用是查询当前所在目录 2. 返回父级目录命令： cd .. 输出： 12345hc@hc-virtual-machine:~/PycharmProjects$ pwd/home/hc/PycharmProjectshc@hc-virtual-machine:~/PycharmProjects$ cd ..hc@hc-virtual-machine:~$ pwd/home/hc 3.进入当前目录的父目录的父目录命令： cd ../.. 输出： 12345hc@hc-virtual-machine:~/PycharmProjects$ pwd/home/hc/PycharmProjectshc@hc-virtual-machine:~/PycharmProjects$ cd ../..hc@hc-virtual-machine:/home$ pwd/home 4. 进入当前用户主目录 “当前用户主目录”和“系统根目录”是两个不同的概念。进入当前用户主目录有两个方法。 命令1： cd 直接输入cd，然后回车 输出：12345hc@hc-virtual-machine:~/PycharmProjects/my_test$ pwd/home/hc/PycharmProjects/my_testhc@hc-virtual-machine:~/PycharmProjects/my_test$ cd hc@hc-virtual-machine:~$ pwd/home/hc 上面的命令是我在非root用户下操作的，现在我切换到root用户下再操作一遍 123456hc@hc-virtual-machine:~/PycharmProjects/my_test$ sudo suroot@hc-virtual-machine:/home/hc/PycharmProjects/my_test# pwd/home/hc/PycharmProjects/my_testroot@hc-virtual-machine:/home/hc/PycharmProjects/my_test# cd root@hc-virtual-machine:~# pwd/root 命令2： cd ~ 输出12345hc@hc-virtual-machine:~/PycharmProjects/my_test$ pwd/home/hc/PycharmProjects/my_testhc@hc-virtual-machine:~/PycharmProjects/my_test$ cd ~hc@hc-virtual-machine:~$ pwd/home/hc 5. 跳转到指定目录命令 cd /home/hc/PycharmProjects/my_test/ 输出12345hc@hc-virtual-machine:/$ pwd/hc@hc-virtual-machine:/$ cd /home/hc/PycharmProjects/my_test/hc@hc-virtual-machine:~/PycharmProjects/my_test$ pwd/home/hc/PycharmProjects/my_test 6.返回进入此目录之前所在的目录命令： cd - 说明：自动跳转到进入此目录之前所在的目录，并输出所在目录名称 输出：123456789hc@hc-virtual-machine:/$ pwd/hc@hc-virtual-machine:/$ cd /home/hc/PycharmProjects/my_test/hc@hc-virtual-machine:~/PycharmProjects/my_test$ pwd/home/hc/PycharmProjects/my_testhc@hc-virtual-machine:~/PycharmProjects/my_test$ cd -/hc@hc-virtual-machine:/$ pwd/ 7. 把上个命令的参数作为cd参数使用命令： cd !$ 输出:12345678hc@hc-virtual-machine:~/PycharmProjects/my_test$ pwd/home/hc/PycharmProjects/my_testhc@hc-virtual-machine:~/PycharmProjects/my_test$ ls /opt/googlehc@hc-virtual-machine:~/PycharmProjects/my_test$ cd !$cd /opt/hc@hc-virtual-machine:/opt$ pwd/opt]]></content>
      <categories>
        <category>linux每日命令</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux每日命令(1)：ls命令]]></title>
    <url>%2F2018%2F10%2F20%2Flinux%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4(1)%EF%BC%9Als%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[ls命令是linux下最常用的命令。ls命令就是list的缩写缺省下ls用来打印出当前目录的清单如果ls指定其他目录那么就会显示指定目录里的文件及文件夹清单。 通过ls 命令不仅可以查看linux文件夹包含的文件而且可以查看文件权限(包括目录、文件夹、文件权限)查看目录信息等等。ls 命令在日常的linux操作中用的很多! 1.命令格式：ls [选项] [目录名] 2.命令功能列出目标目录中所有的子目录和文件。（不包含.开头的文件） 3.常用选项参数 选项参数 作用 -l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来。 -g 类似 -l,但不列出所有者 -o 类似 -l,显示文件的除组信息外的详细信息。 -a 列出目录下的所有文件，包括以 . 开头的文件 -A 同-a，但不列出“.”(表示当前目录)和“..”(表示当前目录的父目录)。 -F 使得ls命令可以在显示子目录的时候在它的文件名之后加上一个斜线(“/”)字符。而文件后面的星号(“*”)字符表示这是一个可执行程序 -r –reverse 依相反次序排列 -R –recursive 同时列出所有子目录层 -t 以文件修改时间排序 -S 根据文件大小排序 -c 根据 ctime(文件状态最后更改的时间) 排序；配合 -l：显示 ctime 但根据名称排序否则：根据 ctime 排序；配合-lt:根据 ctime 排序及显示 ctime -u 配合 -lt:显示访问时间而且依访问时间排序；配合 -l:显示访问时间但根据名称排序；否则：根据访问时间排序 -U 不进行排序;依文件系统原有的次序列出项目 -v 根据版本进行排序 -h 以容易理解的格式列出文件大小 (例如 1K 234M 2G) –si 类似 -h,但文件大小取 1000 的次方而不是 1024 -k 以 k 字节的形式表示文件的大小。 -s 以块大小为单位列出所有文件的大小 -m 所有项目以逗号分隔，并填满整行行宽 -w 自行指定屏幕宽度而不使用目前的数值 -x 逐行列出项目而不是逐栏列出 -X 根据扩展名排序 -1 每行只列出一个文件 –help 显示此帮助信息并离开 –version 显示版本信息并离开 4.常见范例1：列出/home/hc文件夹下的所有文件和目录的详细资料命令1 ls -l -R /home/hc 在使用 ls 命令时要注意命令的格式：在命令提示符后，首先是命令的关键字，接下来是命令参数，在命令参数之前要有一短横线“-”，所有的命令参数都有特定的作用，自己可以根据需要选用一个或者多个参数，在命令参数的后面是命令的操作对象。在以上这条命令“ ls -l -R /home/hc”中，“ls” 是命令关键字，“-l -R”是参数，“ /home/hc”是命令的操作对象。在这条命令中，使用到了两个参数，分别为“l”和“R”，当然，你也可以把他们放在一起使用，如下所示： 命令2 ls -lR /home/hc 这种形式和上面的命令形式执行的结果是完全一样的。另外，如果命令的操作对象位于当前目录中，可以直接对操作对象进行操作;如果不在当前目录则需要给出操作对象的完整路径，例如上面的例子中，我的当前文件夹是hc文件夹，我想对home文件夹下的hc文件进行操作，我可以直接输入 ls -lR hc，也可以用 ls -lR /home/hc。 2：列出当前目录中所有以“t”开头的目录的详细内容，可以使用如下命令：命令： ls -l t* 可以查看当前目录下文件名以“t”开头的所有文件的信息。其实，在命令格式中，方括号内的内容都是可以省略的，对于命令ls而言，如果省略命令参数和操作对象，直接输入“ ls ”，则将会列出当前工作目录的内容清单。 3：只列出文件下的子目录列出 /home/hc/PycharmProjects 文件下面的子目录命令： ls -F /home/hc/PycharmProjects |grep /$ 输出： 12345hc@hc-virtual-machine:~$ ls -F /home/hc/PycharmProjects |grep /$FreshOnline/FreshOnline_env/my_test/py3_test/ 列出 /home/hc/PycharmProjects 文件下面的子目录详细情况 命令： ls -l /home/hc/PycharmProjects | grep &quot;^d&quot; 输出： 12345hc@hc-virtual-machine:~$ ls -l /home/hc/PycharmProjects | grep "^d"drwxr-xr-x 9 hc hc 4096 10月 20 08:56 FreshOnlinedrwxrwxr-x 6 hc hc 4096 10月 19 19:07 FreshOnline_envdrwxrwxr-x 3 hc hc 4096 10月 18 15:24 my_testdrwxrwxr-x 4 hc hc 4096 10月 18 17:58 py3_test 4：列出目前工作目录下所有名称是s 开头的档案，愈新的排愈后面，可以使用如下命令：命令： ls -ltr s* 输出：1234hc@hc-virtual-machine:~$ ls -ltr s*总用量 8drwxr-xr-x 5 hc hc 4096 9月 28 21:28 gnome-system-monitordrwxr-xr-x 4 hc hc 4096 9月 29 08:39 pycharm-professional 5：列出目前工作目录下所有档案及目录;目录于名称后加”/“, 可执行档于名称后加”*”命令： ls -AF 输出： 12hc@hc-virtual-machine:~/PycharmProjects$ ls -AFFreshOnline/ FreshOnline_env/ my_test/ py3_test/ 6：计算当前目录下的文件数和目录数命令： ls -l * |grep &quot;^-&quot;|wc -l ---文件个数 ls -l * |grep &quot;^d&quot;|wc -l ---目录个数 7: 在ls中列出文件的绝对路径命令： ls | sed &quot;s:^:`pwd`/:&quot; 输出： 12345hc@hc-virtual-machine:~/PycharmProjects$ ls | sed "s:^:`pwd`/:"/home/hc/PycharmProjects/FreshOnline/home/hc/PycharmProjects/FreshOnline_env/home/hc/PycharmProjects/my_test/home/hc/PycharmProjects/py3_test 8：列出当前目录下的所有文件（包括隐藏文件）的绝对路径， 对目录不做递归命令： find $PWD -maxdepth 1 | xargs ls -ld 输出： 123456hc@hc-virtual-machine:~/PycharmProjects$ find $PWD -maxdepth 1 | xargs ls -lddrwxrwxr-x 6 hc hc 4096 10月 19 18:22 /home/hc/PycharmProjectsdrwxr-xr-x 9 hc hc 4096 10月 20 08:56 /home/hc/PycharmProjects/FreshOnlinedrwxrwxr-x 6 hc hc 4096 10月 19 19:07 /home/hc/PycharmProjects/FreshOnline_envdrwxrwxr-x 3 hc hc 4096 10月 18 15:24 /home/hc/PycharmProjects/my_testdrwxrwxr-x 4 hc hc 4096 10月 18 17:58 /home/hc/PycharmProjects/py3_test 9：递归列出当前目录下的所有文件（包括隐藏文件）的绝对路径命令： find $PWD | xargs ls -ld 10：指定文件时间输出格式命令： ls -tl --time-style=full-iso 输出：123456hc@hc-virtual-machine:~/PycharmProjects$ ls -tl --time-style=full-iso总用量 16drwxr-xr-x 9 hc hc 4096 2018-10-20 08:56:55.833765666 +0800 FreshOnlinedrwxrwxr-x 6 hc hc 4096 2018-10-19 19:07:08.330876787 +0800 FreshOnline_envdrwxrwxr-x 4 hc hc 4096 2018-10-18 17:58:39.489690632 +0800 py3_testdrwxrwxr-x 3 hc hc 4096 2018-10-18 15:24:06.613354334 +0800 my_test ls -ctl --time-style=long-iso 输出： 123456hc@hc-virtual-machine:~/PycharmProjects$ ls -ctl --time-style=long-iso总用量 16drwxr-xr-x 9 hc hc 4096 2018-10-20 08:56 FreshOnlinedrwxrwxr-x 6 hc hc 4096 2018-10-19 19:07 FreshOnline_envdrwxrwxr-x 4 hc hc 4096 2018-10-18 17:58 py3_testdrwxrwxr-x 3 hc hc 4096 2018-10-18 15:24 my_test 扩展：显示彩色目录列表打开/etc/bashrc, 加入如下一行: alias ls=&quot;ls --color&quot; 下次启动bash时就可以像在Slackware里那样显示彩色的目录列表了, 其中颜色的含义如下: 1. 蓝色--&gt;目录 2. 绿色--&gt;可执行文件 3. 红色--&gt;压缩文件 4. 浅蓝色--&gt;链接文件 5. 灰色--&gt;其他文件]]></content>
      <categories>
        <category>linux每日命令</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用命令大全]]></title>
    <url>%2F2018%2F08%2F31%2Fgit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[记录日常工作中常用git命令，以便备忘查询 初始化git仓库 git initgit init 添加文件到Git仓库 git add 、 git commit分两步： 第一步，使用命令git add 文件名 ，将指定文件添加到版本库的暂存状态。注意，可反复多次使用，添加多个文件；也可以直接 git add . 代表添加所有改变的文件 第二步，使用命令 git commit -m &#39;自定义的提交说明&#39; 将暂存区的文件提交到版本库的分支 我们需要知道Git把管理的文件分为了两个区域四个状态 工作区：当前开发程序所在目录称为工作区，即：工作开发都是在该目录，该区域的文件会有状态的变化且状态由git自动检测，如果程序中文件做任何操作（增、删、改），文件状态均会被检测到，可以使用 【git status】命令查看。 版本库 工作区检测到有文件发生变化，那么意味着较上一个版本之后对程序进行了修改，修改完成之后，可以当做下一版本进行提交，那么就是执行 【git add .】 将所有文件提交到暂存区，然后再执行【git commit -m ‘又一个版本’】提交到版本库的分支即可，之后可以使用【git log】命令查看版本记录。 查看当前仓库状态 git status我们可以用 git status 来查看当前Git仓库状态,如：那些文件被修改过、那些文件还未提交到版本库等。 查看提交的版本记录 git log、 git refloggit log， 命令显示从最近到最远的提交日志，即：历史版本记录 git reflog，用来查看执行回退命令后，在 git log中未显示的记录 查看修改内容 git diff假设我们已经成功地添加并提交了一个readme.txt文件，现在，继续工作了，我们继续修改readme.txt文件 此时，我们使用git status 命令， 可以发现readme.txt文件已经被修改了，但还未提交，但是具体修改了什么，我们无法得知，加入我们此时将其放置，一两周后再回来看，可能会不记得之前改动了什么，此时我们可以使用 git diff readme.txt 来查看readme.txt 文件里修改的内容确定了我们修改了什么内容以后，我们就可以放心大胆的git add . 然后git commit -m&#39;修改readme.txt&#39; 提交此次修改了 要随时掌握工作区的状态，使用 git status 命令。•如果 git status 告诉你有文件被修改过，用 git diff 可以查看修改内容。 版本回退在Git中，用HEAD表示当前版本，也就是最新的提交版），上一个版本就是HEAD^ ，上上一个版本就是HEAD^^，当然往上100 个版本写100个^比较容易数不过来，所以写成HEAD~100。 比如当前版本id为4,我们想跳到上一个版本3去，可以使用下面的命令 回退到上一个版本 git reset --hard HEAD^git reset --hard HEAD^ 或直接指定具体版本 git reset --hard 3 回退到具体版本 git reset --hard commit_id一旦我们执行了回退操作，则 git log中将看不到当前回退到的版本之后的所有版本信息 要想在回退后，看到当前版本之后的信息需要用到git reflog 如果现在又想跳回去，可以使用git reset --hard 4 小结 HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令 git reset --hard commit_id 。 穿梭前，用 git log 可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用 git reflog 查看命令历史，以便确定要回到未来的哪个版本。 撤销工作区的修改git checkout --文件名有时我们不小心写了很多无用的东西，想丢弃工作区的修改，可以使用git checkout --文件名 命令 git checkout -- readme.txt 意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况： 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。总之，就是让这个文件回到最近一次 git commit 或 git add 时的状态 当我们工作区中的内容不小心 git add 了（但是没有git commit），进入了暂存区时，此时要想撤销修改，则需要用到下面的命令 撤销暂存区的修改 git reset HEAD 文件名用命令 git reset HEAD file 可以把暂存区的修改撤销掉（unstage），重新放回工作区：git reset 命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。再用 git status 查看一下，现在暂存区是干净的，工作区有修改还记得如何丢弃工作区的修改吗？git checkout -- 文件名 此时再用 git status，则是干净的 小结 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令 git checkout -- file。 场景2：当你不但改乱了工作区某⽂文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令 git reset HEAD file ，就回到了场景1，第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，则使用git reset --hard commit_id，不过前提是没有推送到远程库。 删除文件 git rm 在Git中，删除也是一个修改操作,当我们直接在文件管理器中删除git仓库所在目录下的文件，或者直接通过rm 文件名来删除某个文件时，git会将其认定为一个修改操作，这样会造成工作区和版本库中不一致，此时有两种情况，根据我们的需求来进行选择 情况1：如果我们确实是想从版本库中删除该文件，那么就用git rm 文件名 命令来进行删除，然后 git commit -m&#39;删除某文件&#39; ，提交此次删除，这样，该文件就从版本库中被删除了 情况2: 不小心误删了，由于版本库中还存在，我们可以直接将误删的文件恢复到版本库中该文件的最新版本，使用命令git checkout -- 文件名,git checkout 其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。但是需要注意的是：这种方法只能恢复文件到最新版本，但会丢失最近一次提交后你修改的内容。 分支管理创建分支 git branch 分支名切换分支 git checkout 分支名也可以直接使用一条命令，来完成上面两个命令的操作 创建并切换分支 git checkout -b 分支名查看当前所属分支 git branchgit branch 命令会列出所有分支，当前分支前面会标一个*号。 合并分支 git merge 分支名比如：我们当前所在分支为master，我们要想将dev分支中的内容合并到master中来，就在master分支下，使用命令 git merge dev 即可 git merge 命令用于合并指定分支到当前分支。合并后，就可以看到，当前master分支和dev分支的最新提交是完全一样的。 注意到,默认情况下,git会采用Fast-forward方式进行合并，即“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。当然，也不是每次合并都能Fast-forward（比如当我们合并时产生了冲突，需要解决冲突时，就无法使用”快进模式”了） 解决合并冲突之所以合并产生冲突，是因为我们进行合并时，我们的合并分支在我们准备合并前已发生变化（大多数情况下，是由于协同开发时，由于别人在我们进行合并之前，先进行了合并操作，导致我们再去合并时，已经发生了变化），因此我们需要根据冲突提升，找出冲突所在地，去解决冲突，在冲突文件中，Git用 &lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们需要对比找出需要删除和保留的代码，最后再将&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;这些符号删除，然后git add . ,git commit -m&#39;解决冲突&#39; ，即合并完成。 合并分支时，可禁用”Fast forward”模式 git merge --no-ff -m &quot;提交信息&quot; 分支名通常，合并分支时，如果可能，Git会用“Fast forward”模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用“Fast forward”模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。--no-ff 参数，表示禁用“Fast forward”,因为禁用了“快速模式”，合并时要创建一个新的commit，所以加上-m参数，把commit描述写进去。 删除分支 git branch -d 分支名如果要丢弃一个没有被合并过的分支，可以通过 git branch -D 分支名 强行删除。 查看分支合并图 git log --graphBug 分支 在我们日常开发中，经常会遇到开发途中，遇到需要修复之前BUG的需求，很自然地，我们会到想创建一个分支来修复它，但是，当前正在dev上进行的工作还没有提交，并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？无法创建新的分支，怎么办？幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作： “暂存”工作区中的代码 git stash使用命令git stash 后，我们当前工作区的代码将被暂存起来（并不是git add 命令存入的那个暂存区）， 这时用 git status 查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。首先确定要在哪个支上修复bug，假定需要在master分支上修复，就从master创建临时分支： 切换分支git checkout master 创建并切换bug分支git checkout -b bug01 git add . 、git commit -m&#39;修复bug01&#39;修复完成后 切换到master分支，并完成合并，最后删除bug01分支： git checkout master git merge --no-ff -m &quot;合并bug1分支&quot; bug01 git branch -d bug01 OK! bug修复完成，是时候切换回dev分支接着干活了 git checkout dev git status通过查看状态发现，我们当前工作区是干净的，我们在修复bug之前写的代码去哪了？我们之前用 git stash把工作区的内容存在某个地方了，现在可以通过命令查看stash记录 查看stash记录 git stash list现在我们要把之前暂存的内容恢复回来，有两种方式 恢复stash内容 一是用 git stash apply 恢复，但是恢复后，stash内容并不删除，你需要用git stash drop 来删除； 另一种方式是用 git stash pop ，恢复的同时把stash内容也删了： 再用 git stash list查看，就看不到任何stash内容了 我们可以多次stash，恢复的时候，先用 git stash list 查看，然后恢复指定的stash，用命令： git stash apply stash@{id} 小结修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；当手头工作没有完成时，先把⼯工作现场 git stash一下，然后去修复bug，修复后，再 gitstash pop ，回到工作现场。 远程仓库git多账号登陆问题设置git全局设置：git config --global user.name &quot;your_name&quot; git config --global user.email &quot;your_email&quot; 需要取消git的全局设置:git config --global --unset user.name git config --global --unset user.email 针对每个项目，单独设置用户名和邮箱，设置方法如下：git config user.name &quot;your_name&quot; git config user.email &quot;your_email&quot; 绑定远程仓库地址 要关联一个远程库，使用命令 git remote add origin 远程仓库地址（如：git@server-name:path/repo-name.git） ；关联后，使用命令 git push -u origin master 第一次推送master分⽀的所有内容；此后，每次本地提交后，只要有必要，就可以使用命令git push origin master 推送最新修改。 从远程库克隆要克隆一个仓库，首先必须知道仓库的地址，然后使用 git clone 远程库地址进行克隆。Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。 Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。 其他常用操作 查看远程库信息，使用 git remote -v； 本地新建的分支如果不推送到远程，对其他人就是不可见的； 从本地推送分支，使用 git push origin 分支名 ，如果推送失败，先用git pull orign 分支名抓取远程的新提交； 在本地创建和远程分支对应的分支，使用 git checkout -b 分支名 origin/分支名，本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联，使用 git branch --set-upstream 分支名 origin/分支名 ； 从远程抓取分支，使用git pull ，如果有冲突，要先处理冲突。 参考：Git教程]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows10环境下安装RabbitMQ(图文步骤)]]></title>
    <url>%2F2018%2F07%2F31%2Fwindows10%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85RabbitMQ(%E5%9B%BE%E6%96%87%E6%AD%A5%E9%AA%A4)%2F</url>
    <content type="text"><![CDATA[记录下本人在win10环境下安装RabbitMQ的步骤，以作备忘。 第一步：下载并安装erlang 原因：RabbitMQ服务端代码是使用并发式语言Erlang编写的，安装Rabbit MQ的前提是安装Erlang。 下载地址：http://www.erlang.org/downloads 根据本机位数选择erlang下载版本。 下载完是这么个东西： 双击，点next就可以。 选择一个自己想保存的地方，然后next、finish就可以。 安装完事儿后要记得配置一下系统的环境变量。此电脑–&gt;鼠标右键“属性”–&gt;高级系统设置–&gt;环境变量–&gt;“新建”系统环境变量 变量名：ERLANG_HOME 变量值就是刚才erlang的安装地址，点击确定。 然后双击系统变量path 点击“新建”，将%ERLANG_HOME%\bin加入到path中。 最后windows键+R键，输入cmd，再输入erl，看到版本号就说明erlang安装成功了。 第二步：下载并安装RabbitMQ 下载地址：http://www.rabbitmq.com/download.html 双击下载后的.exe文件，安装过程与erlang的安装过程相同。 RabbitMQ安装好后接下来安装RabbitMQ-Plugins。打开命令行cd，输入RabbitMQ的sbin目录 我的目录是：D:\Program Files\RabbitMQ Server\rabbitmq_server-3.7.3\sbin 然后在后面输入enable rabbitmq_management```命令进行安装1234567如果```rabbitmq-plugins enable rabbitmq_management```使用报错如下 ![](http://pcqah8keq.bkt.clouddn.com/13.png) 请请使用```rabbitmq-plugins.bat enable rabbitmq_management 安装成功如下： 打开sbin目录，双击rabbitmq-server.bat 等几秒钟看到这个界面后，访问http://localhost:15672 然后可以看到如下界面 默认用户名和密码都是guest 登陆即可。 转自：https://blog.csdn.net/weixin_39735923/article/details/79288578]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python unicode和str拼接报错原因]]></title>
    <url>%2F2018%2F07%2F25%2FPython%20unicode%E5%92%8Cstr%E6%8B%BC%E6%8E%A5%E6%8A%A5%E9%94%99%E5%8E%9F%E5%9B%A0%2F</url>
    <content type="text"><![CDATA[首先来看一段代码 一、例子 123456789101112131415161718192021222324# -*- coding: utf-8 -*-a1 = u'你好'b1 = '中文' print(a1+b1) # 报错a2 = u'你好'b2 = '中文' + a.encode('utf-8')print(b2) # 正常输出type(b2) # stra3 = u'http'b3 = 'abc' + aprint(b3) # 正常输出type(b3) # unicode a1,a2,a3都是unicode对象，unicode是一种编码标准，具体的实现可能是utf-8，utf-16，gbk等等，这就是中文字符串和unicode有密切关系的原因。python内部使用两个字节存储一个unicode对象（unicode对象并不只能是字符串，这两个字节还可以存其他内容），为什么要用unicode而不用str呢，因为中文转码的缘故，因为unicode的优点是便于跨平台。 b1 是str对象，中文字符串。存储方式是字节码。字节码是怎么存的：如果这行代码在python解释器中输入&amp;运行，那么s的格式就是解释器的编码格式；如果这行代码是在源码文件中写入、保存然后执行，那么解释器载入代码时就将s初始化为文件指定编码(比如py文件开头那行的utf-8)； 下面这两种方式都是表示unicode对象 12s1 = u'中文' # s1: &lt;type 'unicode'&gt;s2 = unicode('中文', 'utf-8') # utf8是在指定解码方式, s2: &lt;type 'unicode'&gt; python解释器中 如果 将一个 普通字符串 和 unicode对象字符串 拼接，会默认将普通字符串 用decode(‘ascii’)解码成unicode对象。为什么是用 ascii的方式解码呢，因为这里用的是python的默认编码,也就是defaultencoding = ascii。 所以，如果这个普通字符串 包含中文的话，就会报错，因为用ascii码去解码中文是不够用的。(中文得用unicode解码)。 二、正确的str对象和unicode对象拼接方式只要注意正确的decode、encode方式，统一编码后就能顺利地拼接了。123456789101112# -*- coding: utf-8 -*- s1 = '中文's2 = u'你好'print s1 + unicode(s2, 'utf-8') # 中文你好print s1 + s2.decode('utf-8') # 中文你好print s1.encode('utf-8') + s2 # 中文你好 print type(s1) # &lt;type 'str'&gt;print type(s2) # &lt;type 'unicode'&gt;print type(s1.decode('utf-8')) # &lt;type 'unicode'&gt;print type(s2.encode('utf-8')) # &lt;type 'str'&gt; 对于str要注意当前环境编码方式，也许是控制台那种设定好了的，也许是你自己在代码中指定的。对于unicode对象，一般都是decode得到的，像直接【u’你好’】这种其实不是很常见，所以要注意字符串来源是什么编码，比如从gbk文件或utf8文件中读入的。 参考自： https://blog.csdn.net/index20001/article/details/78974814 https://blog.csdn.net/qq_31739317/article/details/75257726]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python时间格式转换(时间戳、日期、时间、字符串)]]></title>
    <url>%2F2018%2F07%2F24%2FPython%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2(%E6%97%B6%E9%97%B4%E6%88%B3%E3%80%81%E6%97%A5%E6%9C%9F%E3%80%81%E6%97%B6%E9%97%B4%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2)%2F</url>
    <content type="text"><![CDATA[在工作中我们常会对时间戳以及日期时间等格式进行转换，下面介绍了一些常用的Python时间的转换方法，方便以后查询 一、str类型的日期转换为时间戳1234567891011121314# -*- coding: utf-8 -*-import timefrom datetime import datetimetss1 = '2013-10-10 23:40:00'# 转为时间数组timeArray = time.strptime(tss1, "%Y-%m-%d %H:%M:%S")# timeArray可以调用tm_year等print timeArray # time.struct_time# 转为时间戳timeStamp = int(time.mktime(timeArray))print timeStamp # 1381419600 二、时间戳转换:10位（秒级）和13位（毫秒级）时间戳123456789101112131415161718# -*- coding: utf-8 -*-import timefrom datetime import datetimenow_timestamp = time.time()print 'now_timestamp', now_timestamp, type(now_timestamp)# now_timestamp 1532447792.62 &lt;type 'float'&gt;seconds = int(now_timestamp)print '10位秒级', seconds# 10位秒级 1532447792millis1 = int(round(now_timestamp * 1000))print '13位毫秒级1', millis1, type(millis1)# 13位毫秒级1 1532447792615 &lt;type 'long'&gt;millis2 = '%.f' % (now_timestamp * 1000)print '13位毫秒级2', millis2, type(millis2)# 13位毫秒级2 1532447792615 &lt;type 'str'&gt; 三、更改str类型日期的显示格式1234567891011121314# -*- coding: utf-8 -*-import timefrom datetime import datetimetss2 = "2013-10-10 23:40:00"# 转为数组timeArray = time.strptime(tss2, "%Y-%m-%d %H:%M:%S")# 转为其它格式otherStyleTime = time.strftime("%Y/%m/%d %H:%M:%S", timeArray)print otherStyleTime # 2013/10/10 23:40:00tss3 = "2013/10/10 23:40:00"timeArray = time.strptime(tss3, "%Y/%m/%d %H:%M:%S")otherStyleTime = time.strftime("%Y-%m-%d %H:%M:%S", timeArray)print otherStyleTime # 2013-10-10 23:40:00 四、时间戳转换为指定格式的日期12345678910111213141516171819# -*- coding: utf-8 -*-import timefrom datetime import datetime# 使用timetimeStamp = 1381419600timeArray = time.localtime(timeStamp)print timeArray # time.struct_timeotherStyleTime = time.strftime("%Y--%m--%d %H:%M:%S", timeArray)print otherStyleTime # 2013--10--10 23:40:00# 使用datetimeutc_data = datetime.utcfromtimestamp(now_timestamp)print 'utc时间', utc_data, type(utc_data)# utc时间 2018-07-24 15:59:49.501000 &lt;type 'datetime.datetime'&gt;local_data = datetime.fromtimestamp(now_timestamp)print 'local时间', local_data, type(local_data)# local时间 2018-07-24 23:59:49.501000 &lt;type 'datetime.datetime'&gt; 五、时间戳转换为指定格式的日期123456789101112131415# -*- coding: utf-8 -*-import timefrom datetime import datetime# 获取当前时间戳now = int(time.time())timeArray = time.localtime(now)otherStyleTime = time.strftime("%Y--%m--%d %H:%M:%S", timeArray)print otherStyleTime # 2018--07--24 23:59:49# 获取当前时间，数组格式now = datetime.now()otherStyleTime = now.strftime("%Y--%m--%d %H:%M:%S")print otherStyleTime # 2018--07--24 23:59:49 六、获取本地时区当天0点时间戳和时间的一种方法123456789# -*- coding: utf-8 -*-import timefrom datetime import datetime# 方法1print time.mktime(datetime.now().date().timetuple()) # 1532534400.0today = datetime.today()# 方法2print datetime(today.year, today.month, today.day, 0, 0, 0) # 2018-07-26 00:00:00]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>时间</tag>
      </tags>
  </entry>
</search>
