<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[linux每日命令(16)：head命令]]></title>
    <url>%2F2018%2F11%2F09%2Flinux%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4(15)%EF%BC%9Atail%E5%91%BD%E4%BB%A4%20-%20%E5%89%AF%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[head 与 tail 就像它的名字一样的浅显易懂，它是用来显示开头或结尾某个数量的文字区块，head 用来显示档案的开头至标准输出中，而 tail 想当然尔就是看档案的结尾。 一．命令格式：head [参数]... [文件]... 二．命令功能：head 用来显示档案的开头至标准输出中，默认head命令打印其相应文件的开头10行。 三．命令参数： 参数 描述 -q 隐藏文件名 -v 显示文件名 -c&lt;字节&gt; 显示字节数 -n&lt;行数&gt; 显示的行数 四．使用实例：1.输出log1文件的前4行内容命令： head -n 4 log1 输出： 12345678910111213hc@hc-virtual-machine:~/snap$ nl -b a log1 1 我是log1的第一行 2 3 我是log1的第三行 4 我是log1的第四行 5 我是log1的第五行 6 7 我是log1的第七行hc@hc-virtual-machine:~/snap$ head -n 4 log1我是log1的第一行我是log1的第三行我是log1的第四行 2.输出log1文件除最后4行以外的全部内容命令： head -n -4 log1 输出：12345hc@hc-virtual-machine:~/snap$ head -n -4 log1我是log1的第一行我是log1的第三行hc@hc-virtual-machine:~/snap$ 3.输出log1文件的前24个字节命令： head -c 24 log1 输出： 1234hc@hc-virtual-machine:~/snap$ head -c 24 log1我是log1的第一行hc@hc-virtual-machine:~/snap$ 4.输出log1文件的除最后24个字节以外的内容命令： head -c -24 log1 输出： 1234567hc@hc-virtual-machine:~/snap$ head -c -24 log1我是log1的第一行我是log1的第三行我是log1的第四行我是log1的第五行hc@hc-virtual-machine:~/snap$]]></content>
      <categories>
        <category>linux每日命令</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux每日命令(15)：tail命令]]></title>
    <url>%2F2018%2F11%2F08%2Flinux%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4(15)%EF%BC%9Atail%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[tail 命令从指定点开始将文件写到标准输出.使用tail命令的-f选项可以方便的查阅正在改变的日志文件,tail -f filename会把filename里最尾部的内容显示在屏幕上,并且不断刷新,使你看到最新的文件内容. 一．命令格式;tail [必要参数] [选择参数] [文件] 二．命令功能：用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。 三．命令参数： 参数 描述 -f 循环读取 -q 不显示处理信息 -v 显示详细的处理信息 -c&lt;数目&gt; 显示的字节数 -n&lt;行数&gt; 显示行数 –pid=PID 与-f合用,表示在进程ID,PID死掉之后结束. -q –quiet, –silent 从不输出给出文件名的首部 -s –sleep-interval=S 与-f合用,表示在每次反复的间隔休眠S秒 四．使用实例：1.显示log1文件最后3行内容命令： tail -n 3 log1 输出： 123456789101112hc@hc-virtual-machine:~/snap$ nl -b a log1 1 我是log1的第一行 2 3 我是log1的第三行 4 我是log1的第四行 5 我是log1的第五行 6 7 我是log1的第七行hc@hc-virtual-machine:~/snap$ tail -n 3 log1我是log1的第五行我是log1的第七行 2. 从第3行开始显示log1文件内容命令： tail -n +3 log1 输出： 1234567891011121314hc@hc-virtual-machine:~/snap$ nl -b a log1 1 我是log1的第一行 2 3 我是log1的第三行 4 我是log1的第四行 5 我是log1的第五行 6 7 我是log1的第七行hc@hc-virtual-machine:~/snap$ tail -n +3 log1我是log1的第三行我是log1的第四行我是log1的第五行我是log1的第七行 3.循环刷新查看文件内容命令： tail -f test.log 输出: 123456789101112131415161718hc@hc-virtual-machine:~/snap$ ping 127.0.0.1 &gt; test.log &amp; [1] 24615hc@hc-virtual-machine:~/snap$ tail -f test.log64 bytes from 127.0.0.1: icmp_seq=5 ttl=64 time=0.065 ms64 bytes from 127.0.0.1: icmp_seq=6 ttl=64 time=0.068 ms64 bytes from 127.0.0.1: icmp_seq=7 ttl=64 time=0.157 ms64 bytes from 127.0.0.1: icmp_seq=8 ttl=64 time=0.067 ms64 bytes from 127.0.0.1: icmp_seq=9 ttl=64 time=0.034 ms64 bytes from 127.0.0.1: icmp_seq=10 ttl=64 time=0.043 ms64 bytes from 127.0.0.1: icmp_seq=11 ttl=64 time=0.031 ms64 bytes from 127.0.0.1: icmp_seq=12 ttl=64 time=0.076 ms64 bytes from 127.0.0.1: icmp_seq=13 ttl=64 time=0.045 ms64 bytes from 127.0.0.1: icmp_seq=14 ttl=64 time=0.069 ms64 bytes from 127.0.0.1: icmp_seq=15 ttl=64 time=0.067 ms64 bytes from 127.0.0.1: icmp_seq=16 ttl=64 time=0.063 ms^Chc@hc-virtual-machine:~/snap$ ps -ef | less[1]+ 已杀死 ping 127.0.0.1 &gt; test.log 说明： ping 127.0.0.1 &gt; test.log &amp; //在后台ping远程主机。并输出文件到test.log；这种做法也使用于一个以上的档案监视。用Ctrl＋c来终止。 由于加了&amp;,所以输出命令一直在后台运行，想要杀死它就得找到它的pid，然后kill -9 pid，终止输出]]></content>
      <categories>
        <category>linux每日命令</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux每日命令(14)：less命令]]></title>
    <url>%2F2018%2F11%2F07%2Flinux%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4(14)%EF%BC%9Aless%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[less 工具也是对文件或其它输出进行分页显示的工具，应该说是linux正统查看文件内容的工具，功能极其强大。less 的用法比起 more 更加的有弹性。在 more 的时候，我们并没有办法向前面翻， 只能往后面看，但若使用了 less 时，就可以使用 [pageup] [pagedown] 等按键的功能来往前往后翻看文件，更容易用来查看一个文件的内容！除此之外，在 less 里头可以拥有更多的搜索功能，不止可以向下搜，也可以向上搜。 一．命令格式：less [参数] 文件 二．命令功能：less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。 三．命令参数： 参数 描述 -b &lt;缓冲区大小&gt; 设置缓冲区的大小 -e 当文件显示结束后，自动离开 -f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件 -g 只标志最后搜索的关键词 -i 忽略搜索时的大小写 -m 显示类似more命令的百分比 -N 显示每行的行号 -o &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来 -Q 不使用警告音 -s 显示连续空行为一行 -S 行过长时间将超出部分舍弃 -x &lt;数字&gt; 将“tab”键显示为规定的数字空格 /字符串： 向下搜索“字符串”的功能 ?字符串： 向上搜索“字符串”的功能 n： 重复前一个搜索（与 / 或 ? 有关） N： 反向重复前一个搜索（与 / 或 ? 有关） b CentOs向后翻一页（Ubuntu向前翻一页） d 向后翻半页 h 显示帮助界面 Q 退出less 命令 u 向前滚动半页 y 向前滚动一行 空格键 滚动一页 回车键 滚动一行 [pagedown] 向下翻动一页 [pageup] 向上翻动一页 四．使用实例：1.查看文件命令： less log1 输出：123456789hc@hc-virtual-machine:~/snap$ less log1 我是log1的第一行我是log1的第三行我是log1的第四行我是log1的第五行我是log1的第七行log1 (END) 2. ps查看进程信息并通过less分页显示命令： ps -ef |less 输出：123456789101112131415161718192021222324UID PID PPID C STIME TTY TIME CMDroot 1 0 0 10:10 ? 00:00:03 /sbin/init splashroot 2 0 0 10:10 ? 00:00:00 [kthreadd]root 4 2 0 10:10 ? 00:00:00 [kworker/0:0H]root 6 2 0 10:10 ? 00:00:00 [mm_percpu_wq]root 7 2 0 10:10 ? 00:00:00 [ksoftirqd/0]root 8 2 0 10:10 ? 00:00:03 [rcu_sched]root 9 2 0 10:10 ? 00:00:00 [rcu_bh]root 10 2 0 10:10 ? 00:00:00 [migration/0]root 11 2 0 10:10 ? 00:00:00 [watchdog/0]root 12 2 0 10:10 ? 00:00:00 [cpuhp/0]root 13 2 0 10:10 ? 00:00:00 [cpuhp/1]root 14 2 0 10:10 ? 00:00:00 [watchdog/1]root 15 2 0 10:10 ? 00:00:00 [migration/1]root 16 2 0 10:10 ? 00:00:00 [ksoftirqd/1]root 18 2 0 10:10 ? 00:00:00 [kworker/1:0H]root 19 2 0 10:10 ? 00:00:00 [cpuhp/2]root 20 2 0 10:10 ? 00:00:00 [watchdog/2]root 21 2 0 10:10 ? 00:00:00 [migration/2]root 22 2 0 10:10 ? 00:00:00 [ksoftirqd/2]root 24 2 0 10:10 ? 00:00:00 [kworker/2:0H]root 25 2 0 10:10 ? 00:00:00 [cpuhp/3]root 26 2 0 10:10 ? 00:00:00 [watchdog/3]: 说明： 按空格键或者pagedown键，向后翻一页按b（CentOs向后翻一页,Ubuntu向前翻一页）按y向前翻一行，按回车键向后翻一行d 向后翻半页，u前翻半页 3. 查看命令历史使用记录并通过less分页显示命令： history | less 输出：123456789101112131415161718192021222324 1 sudo apt install vmware-install.pl 2 pwd 3 ls 4 pwd 5 ls 6 vmware-install.pl 7 pwd 8 ls 9 pwd 10 ls 11 cd 桌面 12 ls 13 cp VMwareTools-10.1.6-5214329.tar.gz ../ 14 ls 15 cd .. 16 ls 17 tar zxvf VMwareTools-10.1.6-5214329.tar.gz 18 ls 19 cd vmware-tools-distrib/ 20 sudo ./vmware-install.pl 21 sudo -su 22 sudo su 23 ls: 4. 浏览多个文件命令： less log1 log2 输出：12345678910hc@hc-virtual-machine:~/snap$ less log1 log2我是log1的第一行我是log1的第三行我是log1的第四行我是log1的第五行我是log1的第七行log1 (file 1 of 2) (END) - Next: log2 说明： 输入 :n后，切换到 下一个文件，log2 输入 :p 后，切换到 上一个文件，log1 5．附加备注1.全屏导航CentOs下： ctrl + F - 向前移动一屏 ctrl + B - 向后移动一屏 ctrl + D - 向前移动半屏 ctrl + U - 向后移动半屏 Ubuntu下： ctrl + F - 向后移动一屏 ctrl + B - 向前移动一屏 ctrl + D - 向后移动半屏 ctrl + U - 向前移动半屏 2.单行导航CentOs下：j - 向前移动一行 k - 向后移动一行Ubuntu下：j - 向后移动一行 k - 向前移动一行 3.其它导航G - 移动到最后一行 g - 移动到第一行 q / ZZ - 退出 less 命令 4.其它有用的命令v - 使用配置的编辑器编辑当前文件 h - 显示 less 的帮助文档 &amp;pattern - 仅显示匹配模式的行，而不是整个文件 5.标记导航当使用 less 查看大文件时，可以在任何一个位置作标记，可以通过命令导航到标有特定标记的文本位置： ma - 使用 a 标记文本的当前位置 ‘a - 导航到标记 a 处]]></content>
      <categories>
        <category>linux每日命令</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux每日命令(13)：more命令]]></title>
    <url>%2F2018%2F11%2F06%2Flinux%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4(13)%EF%BC%9Amore%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[more命令，功能类似 cat ，cat命令是整个文件的内容从上到下显示在屏幕上。 more会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能 。more命令从前向后读取文件，因此在启动时就加载整个文件。 一．命令格式：more [-dlfpcsu ] [-num ] [+/ pattern] [+ linenum] [file ... ] 二．命令功能：more命令和cat的功能一样都是查看文件里的内容，但有所不同的是more可以按页来查看文件的内容，还支持直接跳转行等功能。 三．命令参数： 参数 描述 +n 从笫n行开始显示 -n 定义屏幕大小为n行 +/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示 -c 从顶部清屏，然后显示 -d 提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能 -l 忽略Ctrl+l（换页）字符 -p 通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似 -s 把连续的多个空行显示为一行 -u 把文件内容中的下画线去掉 四．常用操作命令： 操作命令 描述 Enter 向下n行，需要定义。默认为1行 Ctrl+F 向下滚动一屏 空格键 向下 滚动一屏 Ctrl+B 返回上一屏 = 输出当前行的行号 ：f 输出文件名和当前行的行号 V 调用vi编辑器 !命令 调 用Shell，并执行命令 q 退出more 五. 使用实例1. 从第3行起显示log1文件中的内容命令： more +3 log1 输出：1234567891011121314hc@hc-virtual-machine:~/snap$ nl -b a log1 1 我是log1的第一行 2 3 4 我是log1的第四行 5 我是log1的第五行 6 7 我是log1的第七行hc@hc-virtual-machine:~/snap$ more +3 log1 我是log1的第四行我是log1的第五行我是log1的第七行 2.从文件中查找第一个出现”五”字符串的行，并从该处前两行开始显示输出命令： more +/五 log1 输出：12345678910111213141516hc@hc-virtual-machine:~/snap$ cat log1 我是log1的第一行我是log1的第三行我是log1的第四行我是log1的第五行我是log1的第七行hc@hc-virtual-machine:~/snap$ more +/五 log1...跳过我是log1的第三行我是log1的第四行我是log1的第五行我是log1的第七行 3.设定每屏显示2行命令： more -2 log1 输出: 显示输出文件的第一二行1234hc@hc-virtual-machine:~/snap$ more -2 log1 我是log1的第一行--更多--(20%) 按下ENTER键后,向下n行，需要定义。默认为1行，输出了第三行1234我是log1的第一行我是log1的第三行--更多--(40%) 按下空格键后,向下滚动一屏(当前设置的是一屏为2行)，输出了第四五行1234567hc@hc-virtual-machine:~/snap$ more -2 log1 我是log1的第一行我是log1的第三行我是log1的第四行我是log1的第五行--更多--(79%) 4. 列一个目录下的文件，由于内容太多，我们应该学会用more来分页显示。这得和管道 | 结合起来命令： ls | more -5 输出：12345678910hc@hc-virtual-machine:~$ lsexamples.desktop PycharmProjects vmware-tools-distrib 模板 图片 下载 桌面git_demo snap 公共的 视频 文档 音乐hc@hc-virtual-machine:~$ ls | more -5examples.desktopgit_demoPycharmProjectssnapvmware-tools-distrib--更多-- 说明： 每页显示5个文件信息，按 Ctrl+F 或者 空格键 将会显示下5条文件信息。]]></content>
      <categories>
        <category>linux每日命令</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux每日命令(12)：nl命令]]></title>
    <url>%2F2018%2F11%2F05%2Flinux%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4(12)%EF%BC%9Anl%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[nl命令在linux系统中用来计算文件中行号。nl 可以将输出的文件内容自动的加上行号！其默认的结果与 cat -n 有点不太一样， nl 可以将行号做比较多的显示设计，包括位数与是否自动补齐 0 等等的功能。 一．命令格式：nl [参数]... [文件]... 二．命令参数： 参数 描述 -b 指定行号指定的方式，主要有两种 -b a 表示不论是否为空行，也同样列出行号(类似 cat -n)； -b t 如果有空行，空的那一行不要列出行号(默认值) -n 列出行号表示的方法，主要有三种 -n ln 行号在屏幕的最左方显示 -n rn 行号在自己栏位的最右方显示，且不加 0 -n rz 行号在自己栏位的最右方显示，且加行号不足6位时左边加0补位 -w 指定行号栏位的占用的位数 -p 在逻辑定界符处不重新开始计算。 三．命令功能：nl 命令读取 File 参数（缺省情况下标准输入），计算输入中的行号，将计算过的行号写入标准输出。 在输出中，nl 命令根据您在命令行中指定的标志来计算左边的行。 输入文本必须写在逻辑页中。每个逻辑页有头、主体和页脚节（可以有空节）。 除非使用 -p 标志，nl 命令在每个逻辑页开始的地方重新设置行号。 可以单独为头、主体和页脚节设置行计算标志（例如，头和页脚行可以被计算然而文本行不能）。 四．使用实例：1.用 nl 列出 log1 的内容命令： nl log1 输出：12345678hc@hc-virtual-machine:~/snap$ nl log1 1 我是log1的第一行 2 我是log1的第四行 3 我是log1的第五行 4 我是log1的第七行 说明： 文件中的空白行，nl 不会加上行号 2.用 nl 列出 log1 的内容，空行也加上行号命令： nl -b a log1 输出：12345678hc@hc-virtual-machine:~/snap$ nl -b a log1 1 我是log1的第一行 2 3 4 我是log1的第四行 5 我是log1的第五行 6 7 我是log1的第七行 3.让行号前面自动补上0,统一输出格式12345678910111213141516hc@hc-virtual-machine:~/snap$ nl -b a -n rz log1 000001 我是log1的第一行000002 000003 000004 我是log1的第四行000005 我是log1的第五行000006 000007 我是log1的第七行hc@hc-virtual-machine:~/snap$ nl -b a -n rz -w 3 log1 001 我是log1的第一行002 003 004 我是log1的第四行005 我是log1的第五行006 007 我是log1的第七行 说明： nl -b a -n rz 命令行号默认为六位，要调整位数可以加上参数 -w 3 调整为3位。]]></content>
      <categories>
        <category>linux每日命令</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux每日命令(11)：cat命令]]></title>
    <url>%2F2018%2F11%2F03%2Flinux%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4(11)%EF%BC%9Acat%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[cat命令的用途是连接文件或标准输入并打印。这个命令常用来显示文件内容，或者将几个文件连接起来显示，或者从标准输入读取内容并显示，它常与重定向符号配合使用。 一．命令格式：cat [参数] [文件]... 二．命令功能：cat主要有三大功能： 1.一次显示整个文件:cat filename 2.从键盘创建一个文件:cat &gt; filename 只能创建新文件,不能编辑已有文件. 3.将几个文件合并为一个文件:cat file1 file2 &gt; file 三. 命令参数 参数 描述 -n –number ， 由1开始对所有输出的行数编号 -b –number-nonblank， 和 -n 相似，只不过对于空白行不编号。 -s –squeeze-blank,当遇到有连续两行以上的空白行,就代换为一行的空白行。 -v –show-nonprinting ， 使用 ^ 和 M- 引用，除了 LFD 和 TAB 之外 -E –show-ends ， 在每行结束处显示 $ -T –show-tabs，将 TAB 字符显示为 ^I。 -A –show-all ， 等价于 -vET -e 等价于 -vE -t 与 -vT 等价 四. 使用实例1. 将file1的文档内容覆盖到file2中命令： 不带行号覆盖内容 cat file1 &gt; file2 带行号覆盖内容 cat -n file1 &gt; file2 输出： 123456789101112hc@hc-virtual-machine:~/test$ cat file1我是file1的第一行我是file1的第二行hc@hc-virtual-machine:~/test$ cat file2hc@hc-virtual-machine:~/test$ cat file1 &gt; file2hc@hc-virtual-machine:~/test$ cat file2我是file1的第一行我是file1的第二行hc@hc-virtual-machine:~/test$ cat -n file1 &gt; file2hc@hc-virtual-machine:~/test$ cat file2 1 我是file1的第一行 2 我是file1的第二行 2. 将file1的内容追加到file2的内容中命令： 不带行号追加 cat file1 &gt;&gt; file2 带行号追加（空白行不加行号） 输出：123456789101112131415161718192021222324252627282930313233343536hc@hc-virtual-machine:~/test$ cat file1我是file1的第一行我是file1的第二行hc@hc-virtual-machine:~/test$ cat file2我是file2的第一行我是file2的第6行hc@hc-virtual-machine:~/test$ cat file1 &gt;&gt; file2hc@hc-virtual-machine:~/test$ cat file1我是file1的第一行我是file1的第二行hc@hc-virtual-machine:~/test$ cat file2我是file2的第一行我是file2的第6行我是file1的第一行我是file1的第二行hc@hc-virtual-machine:~/test$ cat -b file2 &gt;&gt; file1hc@hc-virtual-machine:~/test$ cat file1我是file1的第一行我是file1的第二行 1 我是file2的第一行 2 我是file2的第6行 3 我是file1的第一行 4 我是file1的第二行hc@hc-virtual-machine:~/test$ 说明： &gt;是重新编辑内容，&gt;&gt; 是追加内容 3. 清空file1文档内容命令： cat /dev/null &gt; file1 输出：1234567891011121314hc@hc-virtual-machine:~/test$ cat file1我是file1的第一行我是file1的第二行 1 我是file2的第一行 2 我是file2的第6行 3 我是file1的第一行 4 我是file1的第二行hc@hc-virtual-machine:~/test$ cat /dev/null &gt; file1hc@hc-virtual-machine:~/test$ cat file1hc@hc-virtual-machine:~/test$ 4. 倒序输出file2中的内容命令： tac file2 输出： 12345678910111213141516171819hc@hc-virtual-machine:~/test$ cat file2我是file2的第一行我是file2的第6行我是file1的第一行我是file1的第二行hc@hc-virtual-machine:~/test$ tac file2我是file1的第二行我是file1的第一行我是file2的第6行我是file2的第一行hc@hc-virtual-machine:~/test$ 说明： tac 是将 cat 反写过来，所以他的功能就跟 cat 相反， cat 是由第一行到最后一行连续显示在屏幕上，而 tac 则是由最后一行到第一行反向在屏幕上显示出来！]]></content>
      <categories>
        <category>linux每日命令</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux每日命令(10)：touch命令]]></title>
    <url>%2F2018%2F11%2F01%2Flinux%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4(10)%EF%BC%9Atouch%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[linux的touch命令一般用来修改文件时间戳，或者新建一个不存在的文件。 一．命令格式：touch [参数]... 文件... 二．命令参数： 参数 描述 -a 或–time=atime或–time=access或–time=use 只更改存取时间。 -c 或–no-create 不建立任何文档。 -d 使用指定的日期时间，而非现在的时间。 -f 此参数将忽略不予处理，仅负责解决BSD版本touch指令的兼容性问题。 -m 或–time=mtime或–time=modify 只更改变动时间。 -r 把指定文档或目录的日期时间，统统设成和参考文档或目录的日期时间相同。 -t 使用指定的日期时间，而非现在的时间。 三．命令功能：touch命令参数可更改文档或目录的日期时间，包括存取时间和更改时间。 四．使用实例：1. 创建file1和file2两个空文件命令： touch file1 file2 输出： 1234567891011hc@hc-virtual-machine:~/test$ ll总用量 8drwxr-xr-x 2 hc hc 4096 11月 1 09:48 ./drwxr-xr-x 25 hc hc 4096 10月 31 19:52 ../hc@hc-virtual-machine:~/test$ touch file1 file2hc@hc-virtual-machine:~/test$ ll总用量 8drwxr-xr-x 2 hc hc 4096 11月 1 09:48 ./drwxr-xr-x 25 hc hc 4096 10月 31 19:52 ../-rw-r--r-- 1 hc hc 0 11月 1 09:48 file1-rw-r--r-- 1 hc hc 0 11月 1 09:48 file2 说明： 如果加入 -c 参数，当目标文件不存在时，不会创建新文件，如果目标文件存在，则会修改文件时间属性为当前系统时间 1234567891011121314hc@hc-virtual-machine:~/test$ ll总用量 8drwxr-xr-x 2 hc hc 4096 11月 1 09:48 ./drwxr-xr-x 25 hc hc 4096 10月 31 19:52 ../-rw-r--r-- 1 hc hc 0 11月 1 09:48 file1-rw-r--r-- 1 hc hc 0 11月 1 09:48 file2hc@hc-virtual-machine:~/test$ touch -c file2hc@hc-virtual-machine:~/test$ touch -c file3hc@hc-virtual-machine:~/test$ ll总用量 8drwxr-xr-x 2 hc hc 4096 11月 1 09:48 ./drwxr-xr-x 25 hc hc 4096 10月 31 19:52 ../-rw-r--r-- 1 hc hc 0 11月 1 09:48 file1-rw-r--r-- 1 hc hc 0 11月 1 09:50 file2 2. 将file1的时间改为file2的时间命令： touch -r file2 file1 输出： 12345678910111213hc@hc-virtual-machine:~/test$ ll总用量 8drwxr-xr-x 2 hc hc 4096 11月 1 09:48 ./drwxr-xr-x 25 hc hc 4096 10月 31 19:52 ../-rw-r--r-- 1 hc hc 0 11月 1 09:48 file1-rw-r--r-- 1 hc hc 0 11月 1 09:50 file2hc@hc-virtual-machine:~/test$ touch -r file2 file1hc@hc-virtual-machine:~/test$ ll总用量 8drwxr-xr-x 2 hc hc 4096 11月 1 09:48 ./drwxr-xr-x 25 hc hc 4096 10月 31 19:52 ../-rw-r--r-- 1 hc hc 0 11月 1 09:50 file1-rw-r--r-- 1 hc hc 0 11月 1 09:50 file2 3.指定文件的日期时间命令： touch -t 201810011003.17 file2 输出： 123456789101112hc@hc-virtual-machine:~/test$ ll总用量 8drwxr-xr-x 2 hc hc 4096 11月 1 09:48 ./drwxr-xr-x 25 hc hc 4096 10月 31 19:52 ../-rw-r--r-- 1 hc hc 0 11月 1 09:50 file1-rw-r--r-- 1 hc hc 0 11月 1 09:50 file2hc@hc-virtual-machine:~/test$ touch -t 201810011003.17 file2hc@hc-virtual-machine:~/test$ ll总用量 8drwxr-xr-x 2 hc hc 4096 11月 1 09:48 ./drwxr-xr-x 25 hc hc 4096 10月 31 19:52 ../-rw-r--r-- 1 hc hc 0 11月 1 09:50 file1 说明： -t time 使用指定的时间值 time 作为指定文件相应时间戳记的新值。此处的 time规定为如下形式的十进制数: [[CC]YY]MMDDhhmm[.SS] 这里，CC为年数中的前两位，即”世纪数”；YY为年数的后两位，即某世纪中的年数。如果不给出CC的值，则touch 将把年数CCYY限定在1969–2068之内。MM为月数，DD为天将把年数CCYY限定在1969–2068之内。MM为月数，DD为天数，hh 为小时数(几点)，mm为分钟数，SS为秒数。此处秒的设定范围是0–61，这样可以处理闰秒。这些数字组成的时间是环境变量TZ指定的时区中的一个时 间。由于系统的限制，早于1970年1月1日的时间是错误的。]]></content>
      <categories>
        <category>linux每日命令</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux每日命令(9)：cp命令]]></title>
    <url>%2F2018%2F10%2F31%2Flinux%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4(9)%EF%BC%9Acp%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[一．命令格式：cp [参数] source dest 或 cp [参数] source... directory 二．命令功能：将源文件复制至目标文件，或将多个源文件复制至目标目录。 三. 命令参数： 参数 描述 -a 此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。 -b –backup,删除、覆盖目的文件先备份，备份的文件或目录亦建立为符号链接，并指向源文件或目录链接的源文件或目录。假如没有加上这个参数，在复制过程中若遇到符号链接，则会直接复制源文件或目录 -d 复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式。 -f 覆盖已经存在的目标文件而不给出提示。 -i 与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答”y”时目标文件将被覆盖。 -n –no-clobber,不要覆盖已存在的文件(使前面的 -i 选项失效) -p –preserve ,除复制文件的内容外，还保留源文件或目录的属性，包括所有者、所属组、权限与修改时间也复制到新文件中。 -P –parents ,保留源文件或目录的路径，此路径可以是绝对路径或相对路径，且目的目录必须已经存在 -r 若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。 -R –recursive , 递归处理，将指定目录下的文件及子目录一并处理 -s –symbolic-link， 对源文件建立符号链接，而非复制文件 -l 对源文件生成硬链接文件。 四. 命令实例：1. 复制单个文件到目标目录，文件在目标目录中不存在命令： cp log1 dir2 输出： 12345678910111213141516171819202122232425hc@hc-virtual-machine:~/test$ tree ../test/../test/├── dir2├── dir3│ ├── dir1│ ├── file2.txt│ ├── log2│ └── log2~└── log1hc@hc-virtual-machine:~/test$ ll log1 -rw-r--r-- 1 hc hc 0 10月 31 19:18 log1hc@hc-virtual-machine:~/test$ cp log1 dir2hc@hc-virtual-machine:~/test$ tree ../test/../test/├── dir2│ └── log1├── dir3│ ├── dir1│ ├── file2.txt│ ├── log2│ └── log2~└── log1hc@hc-virtual-machine:~/test$ cd dir2hc@hc-virtual-machine:~/test/dir2$ ll log1 -rw-r--r-- 1 hc hc 0 10月 31 19:19 log1 目标文件存在时，会覆盖1234567891011121314hc@hc-virtual-machine:~/test$ ll总用量 16drwxr-xr-x 4 hc hc 4096 10月 31 19:18 ./drwxr-xr-x 25 hc hc 4096 10月 31 19:13 ../drwxr-xr-x 2 hc hc 4096 10月 31 19:19 dir2/drwxr-xr-x 3 hc hc 4096 10月 30 10:08 dir3/-rw-r--r-- 1 hc hc 0 10月 31 19:18 log1hc@hc-virtual-machine:~/test$ cp -a log1 dir2hc@hc-virtual-machine:~/test$ cd dir2hc@hc-virtual-machine:~/test/dir2$ ll总用量 8drwxr-xr-x 2 hc hc 4096 10月 31 19:19 ./drwxr-xr-x 4 hc hc 4096 10月 31 19:18 ../-rw-r--r-- 1 hc hc 0 10月 31 19:18 log1 加上参数 -i会询问是否覆盖，-f强制覆盖说明： 在没有带-a参数时，两个文件的时间是不一样的。在带了-a参数时，两个文件的时间是一致的。 2. 复制整个目录命令： 复制dir3目录到dir2目录下 cp -a dir3 dir2 复制dir2目录到dir3目录下 cp -t dir2 dir3 输出： 目标目录存在时： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455hc@hc-virtual-machine:~/test$ tree ../test/../test/├── dir2│ └── log1├── dir3│ ├── dir1│ ├── file2.txt│ ├── log2│ └── log2~└── log13 directories, 5 fileshc@hc-virtual-machine:~/test$ cp -a dir3 dir2hc@hc-virtual-machine:~/test$ tree ../test/../test/├── dir2│ ├── dir3│ │ ├── dir1│ │ ├── file2.txt│ │ ├── log2│ │ └── log2~│ └── log1├── dir3│ ├── dir1│ ├── file2.txt│ ├── log2│ └── log2~└── log15 directories, 8 fileshc@hc-virtual-machine:~/test$ cp -r dir2 dir3hc@hc-virtual-machine:~/test$ tree ../test/../test/├── dir2│ ├── dir3│ │ ├── dir1│ │ ├── file2.txt│ │ ├── log2│ │ └── log2~│ └── log1├── dir3│ ├── dir1│ ├── dir2│ │ ├── dir3│ │ │ ├── dir1│ │ │ ├── file2.txt│ │ │ ├── log2│ │ │ └── log2~│ │ └── log1│ ├── file2.txt│ ├── log2│ └── log2~└── log18 directories, 12 files 目标目录不存在时：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556hc@hc-virtual-machine:~/test$ lsdir2 dir3 log1hc@hc-virtual-machine:~/test$ cp -r dir2 dir4hc@hc-virtual-machine:~/test$ cp -a dir3 dir5hc@hc-virtual-machine:~/test$ ll总用量 24drwxr-xr-x 6 hc hc 4096 10月 31 19:36 ./drwxr-xr-x 25 hc hc 4096 10月 31 19:13 ../drwxr-xr-x 3 hc hc 4096 10月 31 19:30 dir2/drwxr-xr-x 4 hc hc 4096 10月 31 19:32 dir3/drwxr-xr-x 3 hc hc 4096 10月 31 19:36 dir4/drwxr-xr-x 4 hc hc 4096 10月 31 19:32 dir5/-rw-r--r-- 1 hc hc 0 10月 31 19:18 log1hc@hc-virtual-machine:~/test$ tree ../test/../test/├── dir2│ ├── dir3│ │ ├── dir1│ │ ├── file2.txt│ │ ├── log2│ │ └── log2~│ └── log1├── dir3│ ├── dir1│ ├── dir2│ │ ├── dir3│ │ │ ├── dir1│ │ │ ├── file2.txt│ │ │ ├── log2│ │ │ └── log2~│ │ └── log1│ ├── file2.txt│ ├── log2│ └── log2~├── dir4│ ├── dir3│ │ ├── dir1│ │ ├── file2.txt│ │ ├── log2│ │ └── log2~│ └── log1├── dir5│ ├── dir1│ ├── dir2│ │ ├── dir3│ │ │ ├── dir1│ │ │ ├── file2.txt│ │ │ ├── log2│ │ │ └── log2~│ │ └── log1│ ├── file2.txt│ ├── log2│ └── log2~└── log116 directories, 23 files 说明： 注意目标目录存在与否结果是不一样的。目标目录存在时，整个源目录被复制到目标目录里面。 3.复制的 log.log 建立一个连结档 log_link.log命令： cp -s log1 log1_link 输出： 123456789101112131415hc@hc-virtual-machine:~/test$ lsdir2 dir3 dir4 dir5 log1hc@hc-virtual-machine:~/test$ cp -s log1 log1_linkhc@hc-virtual-machine:~/test$ lsdir2 dir3 dir4 dir5 log1 log1_linkhc@hc-virtual-machine:~/test$ ll总用量 24drwxr-xr-x 6 hc hc 4096 10月 31 19:47 ./drwxr-xr-x 25 hc hc 4096 10月 31 19:13 ../drwxr-xr-x 3 hc hc 4096 10月 31 19:30 dir2/drwxr-xr-x 4 hc hc 4096 10月 31 19:32 dir3/drwxr-xr-x 3 hc hc 4096 10月 31 19:36 dir4/drwxr-xr-x 4 hc hc 4096 10月 31 19:32 dir5/-rw-r--r-- 1 hc hc 0 10月 31 19:18 log1lrwxrwxrwx 1 hc hc 4 10月 31 19:47 log1_link -&gt; log1 说明： 那个 log1_link 是由 -s 的参数造成的，建立的是一个『快捷方式』，所以会看到在文件的最右边，会显示这个文件是『连结』到哪里去的！]]></content>
      <categories>
        <category>linux每日命令</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux每日命令(8)：mv命令]]></title>
    <url>%2F2018%2F10%2F30%2Flinux%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4(8)%EF%BC%9Amv%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[mv命令是move的缩写，可以用来移动文件或者将文件改名（move (rename) files），是Linux系统下常用的命令，经常用来备份文件或者目录。 一．命令格式：mv [选项] 源文件或目录 目标文件或目录 二．命令功能：视mv命令中第二个参数类型的不同（是目标文件还是目标目录），mv命令将文件重命名或将其移至一个新的目录中。当第二个参数类型是文件时，mv命令完成文件重命名，此时，源文件只能有一个（也可以是源目录名），它将所给的源文件或目录重命名为给定的目标文件名。当第二个参数是已存在的目录名称时，源文件或目录参数可以有多个，mv命令将各参数指定的源文件均移至目标目录中。在跨文件系统移动文件时，mv先拷贝，再将原有文件删除，而链至该文件的链接也将丢失。 三．命令参数： 选项 描述 -b 若需覆盖文件，则覆盖前先行备份。 -f force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖 -i 若目标文件 (destination) 已经存在时，就会询问是否覆盖！ -u 若目标文件已经存在，且 source 比较新，才会更新(update) -t 即指定mv的目标目录，该选项适用于移动多个源文件到一个目录的情况，此时目标目录在前，源文件在后。 四．命令实例：1.将文件file1.txt重命名为file2.txt命令： mv file1.txt file2.txt 输出： 12345hc@hc-virtual-machine:~/test$ lsfile1.txthc@hc-virtual-machine:~/test$ mv file1.txt file2.txt hc@hc-virtual-machine:~/test$ lsfile2.txt 2.将文件file2.txt移动到目录dir1中命令： mv file2.txt dir1 输出：123456789101112131415hc@hc-virtual-machine:~/test$ tree ../test/../test/├── dir1│ └── log1└── file2.txt1 directory, 2 fileshc@hc-virtual-machine:~/test$ mv file2.txt dir1hc@hc-virtual-machine:~/test$ tree ../test/../test/└── dir1 ├── file2.txt └── log11 directory, 2 files 3.将文件log1重命名为log2，如果log2已经存在，则询问是否覆盖命令 mv -i log1 log2 输出：12345678910111213hc@hc-virtual-machine:~/test/dir1$ lsfile2.txt log1 log2hc@hc-virtual-machine:~/test/dir1$ cat log1I'm log1hc@hc-virtual-machine:~/test/dir1$ cat log2I'm log2hc@hc-virtual-machine:~/test/dir1$ mv -i log1 log2 mv：是否覆盖'log2'？ yhc@hc-virtual-machine:~/test/dir1$ lsfile2.txt log2hc@hc-virtual-machine:~/test/dir1$ cat log2 I'm log1hc@hc-virtual-machine:~/test/dir1$ 4.将文件log2重命名为log3，无论log3是否存在，不进行询问，直接覆盖命令： mv -f log2 log3 输出：12345678910111213hc@hc-virtual-machine:~/test/dir1$ touch log3hc@hc-virtual-machine:~/test/dir1$ vim log3hc@hc-virtual-machine:~/test/dir1$ lsfile2.txt log2 log3hc@hc-virtual-machine:~/test/dir1$ cat log2I'm log1hc@hc-virtual-machine:~/test/dir1$ cat log3I'm log3hc@hc-virtual-machine:~/test/dir1$ mv -f log2 log3hc@hc-virtual-machine:~/test/dir1$ lsfile2.txt log3hc@hc-virtual-machine:~/test/dir1$ cat log3 I'm log1 说明： -f 这是个危险的选项，使用的时候一定要保持头脑清晰，一般情况下最好不用加上它。 5. 将目录dir1移动到目录dir2中命令： mv dir1 dir2 输出：123456789101112131415161718192021hc@hc-virtual-machine:~/test$ lsdir1hc@hc-virtual-machine:~/test$ mkdir dir2hc@hc-virtual-machine:~/test$ tree ../test/../test/├── dir1│ ├── file2.txt│ └── log3└── dir22 directories, 2 fileshc@hc-virtual-machine:~/test$ mv dir1 dir2hc@hc-virtual-machine:~/test$ tree ../test/../test/└── dir2 └── dir1 ├── file2.txt └── log32 directories, 2 fileshc@hc-virtual-machine:~/test$ 6.将目录dir2重命名为dir3命令： mv dir2 dir3 输出： 123456789101112hc@hc-virtual-machine:~/test$ lsdir2hc@hc-virtual-machine:~/test$ mv dir2 dir3hc@hc-virtual-machine:~/test$ tree ../test/../test/└── dir3 └── dir1 ├── file2.txt └── log32 directories, 2 fileshc@hc-virtual-machine:~/test$ 说明： 当进行目录移动时，如果目标目录名存在，则将源目录移动到目标目录下，成为目标目录的子目录；如果目标目录不存在，则进行重命名操作 7. 移动当前文件夹下的所有文件到上一级目录命令： mv * ../ 输出： 1234567891011121314151617181920212223242526hc@hc-virtual-machine:~/test$ tree dir3/dir3/└── dir1 ├── file2.txt └── log31 directory, 2 fileshc@hc-virtual-machine:~/test$ cd dir3/hc@hc-virtual-machine:~/test/dir3$ lsdir1hc@hc-virtual-machine:~/test/dir3$ cd dir1/hc@hc-virtual-machine:~/test/dir3/dir1$ lsfile2.txt log3hc@hc-virtual-machine:~/test/dir3/dir1$ mv * ../hc@hc-virtual-machine:~/test/dir3/dir1$ lshc@hc-virtual-machine:~/test/dir3/dir1$ cd ..hc@hc-virtual-machine:~/test/dir3$ lsdir1 file2.txt log3hc@hc-virtual-machine:~/test/dir3$ tree ../dir3../dir3├── dir1├── file2.txt└── log31 directory, 2 fileshc@hc-virtual-machine:~/test/dir3$ 8.将目录dir3下的所有内容移到dir2目录下命令： mv dir3/* dir2 输出： 123456789101112131415161718192021222324hc@hc-virtual-machine:~/test$ tree ../test/../test/├── dir2└── dir3 ├── dir1 ├── file2.txt └── log33 directories, 2 fileshc@hc-virtual-machine:~/test$ lsdir2 dir3hc@hc-virtual-machine:~/test$ mv dir3/* dir2hc@hc-virtual-machine:~/test$ lsdir2 dir3hc@hc-virtual-machine:~/test$ tree ../test/../test/├── dir2│ ├── dir1│ ├── file2.txt│ └── log3└── dir33 directories, 2 fileshc@hc-virtual-machine:~/test$ 9.将当前目录（dir2）下的dir1,file2.txt,log3移动到dir3目录下命令： mv -t ../dir3 dir1 file2.txt log3 输出： 123456789101112131415161718192021hc@hc-virtual-machine:~/test$ tree ../test/../test/├── dir2│ ├── dir1│ ├── file2.txt│ └── log3└── dir3hc@hc-virtual-machine:~/test$ cd dir2hc@hc-virtual-machine:~/test/dir2$ lsdir1 file2.txt log3hc@hc-virtual-machine:~/test/dir2$ mv -t ../dir3 dir1 file2.txt log3 hc@hc-virtual-machine:~/test/dir2$ tree ../../test/../../test/├── dir2└── dir3 ├── dir1 ├── file2.txt └── log33 directories, 2 fileshc@hc-virtual-machine:~/test/dir2$ 说明： -t ： –target-directory=DIRECTORY move all SOURCE arguments into DIRECTORY，即指定mv的目标目录，该选项适用于移动多个源文件到一个目录的情况，此时目标目录在前，源文件在后。 10.将log3重命名为log2对log2进行的内容进行覆盖，并给log2源内容进行备份命令： mv log3 -b log2 输出： 1234567891011121314hc@hc-virtual-machine:~/test/dir3$ lsdir1 file2.txt log2 log3hc@hc-virtual-machine:~/test/dir3$ cat log22hc@hc-virtual-machine:~/test/dir3$ cat log3I'm log1hc@hc-virtual-machine:~/test/dir3$ mv log3 -b log2hc@hc-virtual-machine:~/test/dir3$ lsdir1 file2.txt log2 log2~hc@hc-virtual-machine:~/test/dir3$ cat log2I'm log1hc@hc-virtual-machine:~/test/dir3$ cat log2~2hc@hc-virtual-machine:~/test/dir3$ 说明： -b 不接受参数，mv会去读取环境变量VERSION_CONTROL来作为备份策略。 –backup该选项指定如果目标文件存在时的动作，共有四种备份策略： 1.CONTROL=none或off : 不备份。 2.CONTROL=numbered或t：数字编号的备份 3.CONTROL=existing或nil：如果存在以数字编号的备份，则继续编号备份m+1…n： 执行mv操作前已存在以数字编号的文件log2.txt.~1~，那么再次执行将产生log2.txt~2~，以次类推。如果之前没有以数字编号的文件，则使用下面讲到的简单备份。 4.CONTROL=simple或never：使用简单备份：在被覆盖前进行了简单备份，简单备份只能有一份，再次被覆盖时，简单备份也会被覆盖。]]></content>
      <categories>
        <category>linux每日命令</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux每日命令(7)：rmdir命令]]></title>
    <url>%2F2018%2F10%2F29%2Flinux%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4(7)%EF%BC%9Armdir%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[rmdir是常用的命令，该命令的功能是删除空目录，一个目录被删除之前必须是空的。（注意，rm - r dir命令可代替rmdir，但是有很大危险性。）删除某目录时也必须具有对父目录的写权限。 一.命令格式rmdir [参数] 目录 二．命令功能：该命令从一个目录中删除一个或多个子目录项，删除某目录时也必须具有对父目录的写权限。 三．命令参数： 参数 描述 -p 递归删除目录dirname，当子目录删除后其父目录为空时，也一同被删除。如果整个路径被删除或者由于某种原因保留部分路径，则系统在标准输出上显示相应的信息。 -v –verbose,显示指令执行过程 四. 命令示例1.删除空目录dir31命令： rmdir dir31 输出： 123456789101112131415161718192021222324hc@hc-virtual-machine:~$ tree test1/test1/├── dir1│ ├── dir11│ └── file1└── dir2│ └── dir21└── dir3 └── dir314 directories, 1 filehc@hc-virtual-machine:~$ rmdir test1/dir1/file1rmdir: 删除 'test1/dir1/file1' 失败: 不是目录hc@hc-virtual-machine:~$ rmdir test1/dir3rmdir: 删除 'test1/dir3' 失败: 目录非空hc@hc-virtual-machine:~$ rmdir test1/dir3/dir31hc@hc-virtual-machine:~$ tree test1/test1/├── dir1│ ├── dir11│ └── file1└── dir2│ └── dir21└── dir3 说明： rmdir 目录名 ，不能用来删除文件，也不能删除非空目录，只能用来删除单个空目录 2. “递归”删除空目录（此“递归”指“反向递归”，删除父级空目录）命令： rmdir -p test1/dir2/dir21/ 输出： 123456789101112131415161718hc@hc-virtual-machine:~$ tree test1/test1/├── dir1│ ├── dir11│ └── file1└── dir2 └── dir214 directories, 1 filehc@hc-virtual-machine:~$ rmdir -p test1/dir2/dir21/rmdir: 删除目录 'test1' 失败: 目录非空hc@hc-virtual-machine:~$ tree test1/test1/└── dir1 ├── dir11 └── file12 directories, 1 file 说明：删除dir2目录下的dir21目录，如果删除后，dir21目录的父级目录为空目录，则删除其父级目录dir2，如果dir2的目录被删除后，test1目录为空目录，则接着删除，直到遇到父级目录不为空目录，则停止删除 rmdir -p 当该目录的子目录被删除后使其也成为空目录的话，则顺便一并删除该目录 3. 显示删除过程命令： rmdir -pv test1/dir1/dir11/ 输出：123456789101112hc@hc-virtual-machine:~$ lsPycharmProjects snap test1 公共的 模板 视频 图片 文档 下载 音乐 桌面hc@hc-virtual-machine:~$ tree test1/test1/└── dir1 └── dir11hc@hc-virtual-machine:~$ rmdir -pv test1/dir1/dir11/rmdir: 正在删除目录 'test1/dir1/dir11/'rmdir: 正在删除目录 'test1/dir1'rmdir: 正在删除目录 'test1'hc@hc-virtual-machine:~$ lsPycharmProjects snap 公共的 模板 视频 图片 文档 下载 音乐 桌面]]></content>
      <categories>
        <category>linux每日命令</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux每日命令(6)：rm命令]]></title>
    <url>%2F2018%2F10%2F26%2Flinux%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4(6)%EF%BC%9Arm%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[rm是常用的命令，该命令的功能为删除一个目录中的一个或多个文件或目录，它也可以将某个目录及其下的所有文件及子目录均删除。对于链接文件，只是删除了链接，原有文件均保持不变。 rm是一个危险的命令，使用的时候要特别当心，尤其对于新手，否则整个系统就会毁在这个命令（比如在/（根目录）下执行rm * -rf）。所以，我们在执行rm之前最好先确认一下在哪个目录，到底要删除什么东西，操作时保持高度清醒的头脑。 一. 命令格式：rm [选项] 文件 二. 命令功能：删除一个目录中的一个或多个文件或目录，如果没有使用- r参数，则rm不会删除目录。如果使用 rm 来删除文件，通常仍可以将该文件恢复原状。 三. 命令参数选项 参数 描述 -f –force,忽略不存在的文件，从不给出提示。 -i –interactive,进行交互式删除 -r (-R) –recursive , 指示rm将参数中列出的全部目录和子目录均递归地删除。 -v –verbose, 详细显示进行的步骤 –help 显示此帮助信息并退出 –version 输出版本信息并退出 四. 命令实例1. 删除文件命令： rm 文件名 输出： 123456hc@hc-virtual-machine:~/test2/test5$ lsfile1 scf test5-1hc@hc-virtual-machine:~/test2/test5$ rm file1 rm：是否删除普通空文件 'file1'？ yhc@hc-virtual-machine:~/test2/test5$ lsscf test5-1 说明： 输入rm file1命令后，系统会询问是否删除，输入y后就会删除文件，不想删除则数据n。如果没有进行询问，建议加上，毕竟删除操作需谨慎！ 方法： vi ~/.bashrc 然后再里面加入 alias rm=&apos;rm -i&apos; 意思是 rm命令 实际使用的是 rm -i 交互模式，需要进行确认注意，此处 rm 和 = 之间不能有空格，否则会有找不到rm命令的提示， 然后在终端执行这条命令，使得刚才的修改即刻生效： source ~/.bashrc 2. 强行删除file，系统不进行确认提示。命令： rm -f 文件名 输出： 12345hc@hc-virtual-machine:~/test2/test5$ lsfile2 scf test5-1hc@hc-virtual-machine:~/test2/test5$ rm -f file2 hc@hc-virtual-machine:~/test2/test5$ lsscf test5-1 3. 删除当前目录下的所有.log结尾的文件，删除前逐一询问确认命令： rm -i *.log 输出：12345678hc@hc-virtual-machine:~/test2/test5/test5-1$ lslog1.log log2.log log3.loghc@hc-virtual-machine:~/test2/test5/test5-1$ rm -i *.logrm：是否删除普通空文件 'log1.log'？ yrm：是否删除普通空文件 'log2.log'？ yrm：是否删除普通空文件 'log3.log'？ yhc@hc-virtual-machine:~/test2/test5/test5-1$ lshc@hc-virtual-machine:~/test2/test5/test5-1$ 说明： touch 是创建文件的命令 mkdir 是创建目录的命令 touch 1.log 2.log 3.log 如果一次性创建多个连续的文件/目录可以使用{1..3} 例如：一次创建3个.log文件 touch {1..3}.log 4. 删除test5目录及其子目录里的所有的内容命令： rm -r test5 输出：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152hc@hc-virtual-machine:~/test2$ lstest22 test3 test4 test5hc@hc-virtual-machine:~/test2$ tree test5test5├── log.log├── scf│ ├── bin│ ├── doc│ │ ├── info│ │ └── product│ ├── lib│ ├── logs│ │ ├── info│ │ └── product│ └── service│ └── deploy│ ├── info│ └── product└── test5-1 └── log4.log14 directories, 2 fileshc@hc-virtual-machine:~/test2$ lstest22 test3 test4 test5hc@hc-virtual-machine:~/test2$ rm -r test5rm：是否进入目录'test5'? yrm：是否进入目录'test5/scf'? yrm：是否进入目录'test5/scf/logs'? yrm：是否删除目录 'test5/scf/logs/info'？ yrm：是否删除目录 'test5/scf/logs/product'？ yrm：是否删除目录 'test5/scf/logs'？ yrm：是否进入目录'test5/scf/service'? yrm：是否进入目录'test5/scf/service/deploy'? yrm：是否删除目录 'test5/scf/service/deploy/info'？ yrm：是否删除目录 'test5/scf/service/deploy/product'？ yrm：是否删除目录 'test5/scf/service/deploy'？ yrm：是否删除目录 'test5/scf/service'？ yrm：是否删除目录 'test5/scf/bin'？ yrm：是否进入目录'test5/scf/doc'? yrm：是否删除目录 'test5/scf/doc/info'？ yrm：是否删除目录 'test5/scf/doc/product'？ yrm：是否删除目录 'test5/scf/doc'？ yrm：是否删除目录 'test5/scf/lib'？ yrm：是否删除目录 'test5/scf'？ yrm：是否进入目录'test5/test5-1'? yrm：是否删除普通空文件 'test5/test5-1/log4.log'？ yrm：是否删除目录 'test5/test5-1'？ yrm：是否删除普通空文件 'test5/log.log'？ yrm：是否删除目录 'test5'？ yhc@hc-virtual-machine:~/test2$ lstest22 test3 test4hc@hc-virtual-machine:~/test2$ 5. 删除test5目录及其子目录里的所有的内容，且不用进行询问确认命令： rm -rf test5 6. 创建、删除以-开头的文件命令： 在当前目录下创建文件名为-a和-b的文件 方法一： touch ./-a 方法二： touch -- -b 删除当前目录下文件名为-a和-b 的文件 方法一： rm -- -a 方法二： rm ./-b 输出： 12345678910111213141516171819202122hc@hc-virtual-machine:~/test2/test4$ lshc@hc-virtual-machine:~/test2/test4$ touch -atouch: 缺少了文件操作数Try 'touch --help' for more information.hc@hc-virtual-machine:~/test2/test4$ touch ./-ahc@hc-virtual-machine:~/test2/test4$ ls-ahc@hc-virtual-machine:~/test2/test4$ touch -- -bhc@hc-virtual-machine:~/test2/test4$ ls-a -bhc@hc-virtual-machine:~/test2/test4$ rm -arm: 不适用的选项 -- aTry 'rm ./-a' to remove the file '-a'.Try 'rm --help' for more information.hc@hc-virtual-machine:~/test2/test4$ rm -- -arm：是否删除普通空文件 '-a'？ yhc@hc-virtual-machine:~/test2/test4$ ls-bhc@hc-virtual-machine:~/test2/test4$ rm ./-brm：是否删除普通空文件 './-b'？ yhc@hc-virtual-machine:~/test2/test4$ lshc@hc-virtual-machine:~/test2/test4$ 说明： 档名最好不要使用 “-“ 号开头， 因为 “-“ 后面接的是选项，因此，单纯的使用『 rm -a 』系统的命令就会误判。所以，只能用避过首位字节是 “-“ 的方法啦！ 就是加上本目录『 ./ 』即可！如果 man rm 查看使用方法的话，其实还有一种方法，那就是『 rm – -f 』（另外一种方法而已）。 7. 自定义回收站功能命令： myrm(){ D=/tmp/$(date +%Y%m%d%H%M%S); mkdir -p $D; mv &quot;$@&quot; $D &amp;&amp; echo &quot;moved to $D ok&quot;; } 说明：1234567891011121314myrm()&#123; D=/tmp/$(date +%Y%m%d%H%M%S); #在/tmp文件夹中创建名为“当前日期”的文件；#其中“date+%Y%m%d%H%M%S”是规定了日期的输出格式；mkdir -p $D; #以变量D中的路径创建文件夹。mv "$@" $D &amp;&amp; echo "moved to $D ok"; #将所要删除的文件移入变量D中的文件夹内，移入成功后，输出移动成功。&#125;alias rm='myrm'#命令别名定义方式，此定义成功后，无论输入rm或myrm系统都会做出相同操作。 输出：123456789101112131415hc@hc-virtual-machine:/tmp$ myrm()&#123; D=/tmp/$(date +%Y%m%d%H%M%S); mkdir -p $D; mv "$@" $D &amp;&amp; echo "moved to $D ok"; &#125;hc@hc-virtual-machine:/tmp$ alias rm='myrm'hc@hc-virtual-machine:/tmp$ touch &#123;1..4&#125;.loghc@hc-virtual-machine:/tmp$ ls1.log 2.log 3.log 4.loghc@hc-virtual-machine:/tmp$ rm [1234].logmoved to /tmp/20181026111028 okhc@hc-virtual-machine:/tmp$ ls20181026111028hc@hc-virtual-machine:/tmp$ cd 20181026111028/hc@hc-virtual-machine:/tmp/20181026111028$ ls1.log 2.log 3.log 4.log 说明： 上面的操作过程模拟了回收站的效果，即删除文件的时候只是把文件放到一个临时目录中，这样在需要的时候还可以恢复过来。 由于我们当前已将rm绑定为myrm，所以我们无法执行删除操作 临时设置rm命令别名为myrm alias rm=&apos;myrm&apos; 此时若想删除回收站里的文件，由于是临时的，所以换一个命令行窗口后，绑定就会失效即换一个命令行窗口执行rm -r 命令删除即可 如果不想换命令行窗口，可以用 sudo rm -rf 目录名 删除回收站的文件 或者解除临时绑定 unalias rm 输出： 1234567891011121314151617181920hc@hc-virtual-machine:/tmp/20181026111444$ alias alias alert='notify-send --urgency=low -i "$([ $? = 0 ] &amp;&amp; echo terminal || echo error)" "$(history|tail -n1|sed -e '\''s/^\s*[0-9]\+\s*//;s/[;&amp;|]\s*alert$//'\'')"'alias egrep='egrep --color=auto'alias fgrep='fgrep --color=auto'alias grep='grep --color=auto'alias l='ls -CF'alias la='ls -A'alias ll='ls -alF'alias ls='ls --color=auto'alias rm='myrm'hc@hc-virtual-machine:/tmp/20181026111444$ unalias rmhc@hc-virtual-machine:/tmp/20181026111444$ alias alias alert='notify-send --urgency=low -i "$([ $? = 0 ] &amp;&amp; echo terminal || echo error)" "$(history|tail -n1|sed -e '\''s/^\s*[0-9]\+\s*//;s/[;&amp;|]\s*alert$//'\'')"'alias egrep='egrep --color=auto'alias fgrep='fgrep --color=auto'alias grep='grep --color=auto'alias l='ls -CF'alias la='ls -A'alias ll='ls -alF'alias ls='ls --color=auto']]></content>
      <categories>
        <category>linux每日命令</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux每日命令(5)：mkdir命令]]></title>
    <url>%2F2018%2F10%2F25%2Flinux%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4(5)%EF%BC%9Amkdir%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[linux mkdir 命令用来创建指定的名称的目录，要求创建目录的用户在当前目录中具有写权限，并且指定的目录名不能是当前目录中已有的目录。 1．命令格式：mkdir [选项] 目录名或路径名 2．命令功能：通过 mkdir 命令可以实现在指定位置创建以 DirName(指定的文件名)命名的文件夹或目录。要创建文件夹或目录的用户必须对所创建的文件夹的父文件夹具有写权限。并且，所创建的文件夹(目录)不能与其父目录(即父文件夹)中的文件名重名，即同一个目录下不能有同名的(区分大小写)。 3．命令参数： 参数 描述 -m –mode=模式，设定权限&lt;模式&gt; (类似 chmod) -p –parents 可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后,系统将自动建立好那些尚不存在的目录,即一次可以建立多个目录; -v –verbose , 每次创建新目录都显示信息 –help 显示此帮助信息并退出 –version 输出版本信息并退出 4．命令实例：1：创建一个空目录命令： mkdir test1 输出： 12345hc@hc-virtual-machine:~$ lsPycharmProjects snap 公共的 模板 视频 图片 文档 下载 音乐 桌面hc@hc-virtual-machine:~$ mkdir test1hc@hc-virtual-machine:~$ lsPycharmProjects snap test1 公共的 模板 视频 图片 文档 下载 音乐 桌面 2：递归创建多个目录命令： mkdir -p test2/test22 输出： 1234567hc@hc-virtual-machine:~$ mkdir -p test2/test22hc@hc-virtual-machine:~$ lsPycharmProjects test1 公共的 视频 文档 音乐snap test2 模板 图片 下载 桌面hc@hc-virtual-machine:~$ cd test2/hc@hc-virtual-machine:~/test2$ lstest22 3：创建权限为777的目录命令： mkdir -m 777 test3 输出： 1234567hc@hc-virtual-machine:~/test2$ mkdir -m 777 test3hc@hc-virtual-machine:~/test2$ ll总用量 16drwxrwxr-x 4 hc hc 4096 10月 25 09:13 ./drwxr-xr-x 25 hc hc 4096 10月 25 09:11 ../drwxrwxr-x 2 hc hc 4096 10月 25 09:11 test22/drwxrwxrwx 2 hc hc 4096 10月 25 09:13 test3/ 说明： ll 与 ls -l 命令效果相同 test3 的权限为rwxrwxrwx 4：创建新目录并显示创建信息命令： mkdir -v test4 输出： 1234hc@hc-virtual-machine:~/test2$ mkdir -v test4mkdir: 已创建目录 'test4'hc@hc-virtual-machine:~/test2$ lstest22 test3 test4 5：创建目录及其子目录并显示创建信息命令： mkdir -vp test5/test5-1 输出： 12345678hc@hc-virtual-machine:~/test2$ mkdir -vp test5/test5-1mkdir: 已创建目录 'test5'mkdir: 已创建目录 'test5/test5-1'hc@hc-virtual-machine:~/test2$ lstest22 test3 test4 test5hc@hc-virtual-machine:~/test2$ cd test5/hc@hc-virtual-machine:~/test2/test5$ lstest5-1 6. 通过一个命令创建出项目的目录结构命令： mkdir -vp scf/{lib/,bin/,doc/{info,product},logs/{info,product},service/deploy/{info,product}} 输出： 12345678910111213141516171819202122232425262728293031323334353637hc@hc-virtual-machine:~/test2/test5$ lstest5-1hc@hc-virtual-machine:~/test2/test5$ pwd/home/hc/test2/test5hc@hc-virtual-machine:~/test2/test5$ mkdir -vp scf/&#123;lib/,bin/,doc/&#123;info,product&#125;,logs/&#123;info,product&#125;,service/deploy/&#123;info,product&#125;&#125;mkdir: 已创建目录 'scf'mkdir: 已创建目录 'scf/lib/'mkdir: 已创建目录 'scf/bin/'mkdir: 已创建目录 'scf/doc'mkdir: 已创建目录 'scf/doc/info'mkdir: 已创建目录 'scf/doc/product'mkdir: 已创建目录 'scf/logs'mkdir: 已创建目录 'scf/logs/info'mkdir: 已创建目录 'scf/logs/product'mkdir: 已创建目录 'scf/service'mkdir: 已创建目录 'scf/service/deploy'mkdir: 已创建目录 'scf/service/deploy/info'mkdir: 已创建目录 'scf/service/deploy/product'hc@hc-virtual-machine:~/test2/test5$ lsscf test5-1hc@hc-virtual-machine:~/test2/test5$ tree scf/scf/├── bin├── doc│ ├── info│ └── product├── lib├── logs│ ├── info│ └── product└── service └── deploy ├── info └── product12 directories, 0 fileshc@hc-virtual-machine:~/test2/test5$ 说明： tree命令可以用来查看目录树，需要自行安装后才能使用，Ubuntu安装命令： apt install tree]]></content>
      <categories>
        <category>linux每日命令</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux每日命令(4)：pwd命令]]></title>
    <url>%2F2018%2F10%2F24%2Flinux%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4(4)%EF%BC%9Apwd%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Linux中用 pwd 命令来查看”当前工作目录“的完整路径。 简单得说，每当你在终端进行操作时，你都会有一个当前工作目录。 在不太确定当前位置时，就会使用pwd来判定当前目录在文件系统内的确切位置。 1．命令格式：pwd [参数] 2. 命令功能： pwd 代表的是‘Print Working Directory’（打印当前目录）。如它的名字那样，‘pwd’会打印出当前工作目录，或简单的来说就是当前用户所位于的目录。它会打印出以根目录 (/)为起点的完整目录名（绝对目录） 3. 常用参数：一般情况下不带任何参数 参数 描述 -L 即逻辑路径logical，当目录为连接路径时，显示连接路径 -P 即物理路径physical，显示实际物理路径，而非使用连接（link）路径 如果同时使用了‘-L‘和‘-P‘，‘-L‘会有更高的优先级。如果没有指定参数，pwd会避开所有的软链接，也就是说会使用‘-P‘参数。 4. 常用示例1. 查看pwd命令命令： man pwd 输出:123456789101112131415161718192021222324PWD(1) User Commands PWD(1)NAME pwd - print name of current/working directorySYNOPSIS pwd [OPTION]...DESCRIPTION Print the full filename of the current working directory. -L, --logical use PWD from environment, even if it contains symlinks -P, --physical avoid all symlinks --help display this help and exit --version output version information and exit If no option is specified, -P is assumed. Manual page pwd(1) line 1 (press h for help or q to quit) 2. 显示当前目录所在路径.命令： pwd 输出：12hc@hc-virtual-machine:~/PycharmProjects/py3_test$ pwd/home/hc/PycharmProjects/py3_test 目录结构如下：1234567891011121314151617181920212223242526272829hc@hc-virtual-machine:~/PycharmProjects$ tree -L 2.├── FreshOnline│ ├── apps│ ├── db_tools│ ├── extra_apps│ ├── FreshMartOnline│ ├── manage.py│ ├── media│ ├── README.md│ └── requirements.txt├── FreshOnline_env│ ├── bin│ ├── include│ ├── lib│ ├── lib64 -&gt; lib│ ├── pip-selfcheck.json│ ├── pyvenv.cfg│ └── share├── my_test│ ├── 2018.log│ ├── link2018 -&gt; 2018.log│ ├── ln2018│ └── test├── py3_test│ ├── t1.py│ └── venv└── test └── my_test -&gt; /home/hc/PycharmProjects/my_test 说明：目录为连接路径时，pwd -P 显示出实际路径，而非使用连接（link）路径；pwd显示的是连接路径 示例如下： PycharmProjects/test目录下有一个my_test连接文件,指向PycharmProjects/my_test目录,进入test目录下的my_test目录，使用pwd，显示结果与pwd -L 一致，是逻辑（连接）路径，要查看实际物理路径则使用pwd -P 1234567891011121314hc@hc-virtual-machine:~/PycharmProjects/test$ pwd/home/hc/PycharmProjects/testhc@hc-virtual-machine:~/PycharmProjects/test$ ll总用量 8drwxr-xr-x 2 hc hc 4096 10月 23 13:38 ./drwxrwxr-x 7 hc hc 4096 10月 23 13:30 ../lrwxrwxrwx 1 hc hc 32 10月 23 13:38 my_test -&gt; /home/hc/PycharmProjects/my_test/hc@hc-virtual-machine:~/PycharmProjects/test$ cd my_testhc@hc-virtual-machine:~/PycharmProjects/test/my_test$ pwd/home/hc/PycharmProjects/test/my_testhc@hc-virtual-machine:~/PycharmProjects/test/my_test$ pwd -P/home/hc/PycharmProjects/my_testhc@hc-virtual-machine:~/PycharmProjects/test/my_test$ pwd -L/home/hc/PycharmProjects/test/my_test 3. 多层连接文件时，显示所有连接文件最终指向的文件全路径 /root目录下面有个dir1目录，test连接文件指向dir1目录 /opt目录下面有一个test连接文件，指向/root/test连接文件 通过cd命令进入/opt/test pwd默认，只显示连接文件的全路径 123456789101112131415root@hc-virtual-machine:~# pwd/rootroot@hc-virtual-machine:~# ll total 12drwxr-xr-x 2 root root 4096 Apr 24 05:51 dir1lrwxrwxrwx 1 root root 5 Apr 24 05:54 test -&gt; dir1/root@hc-virtual-machine:~# ll /opt/ total 20drwx------ 16 sgl sgl 4096 Oct 17 2015 sgllrwxrwxrwx 1 root root 10 Apr 24 05:55 test -&gt; /root/testroot@hc-virtual-machine:~# cd /opt/test/ root@hc-virtual-machine:~# pwd /opt/testroot@hc-virtual-machine:~# pwd -P /root/dir1 pwd -P 显示连接文件最终指向的文件的全路径。注意这里不是/root/test。]]></content>
      <categories>
        <category>linux每日命令</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何优雅的退出关闭重启gunicorn进程]]></title>
    <url>%2F2018%2F10%2F24%2F%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E9%80%80%E5%87%BA%E5%85%B3%E9%97%AD%E9%87%8D%E5%90%AFgunicorn%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[在工作中，会发现gunicorn启动的web服务，无论怎么使用kill -9 进程号都是无法杀死gunicorn，经过我一番百度和谷歌，发现想要删除gunicorn进程其实很简单。 1. 寻找masterpid通过执行如下命令，可以获取Gunicorn进程树： 1pstree -ap|grep gunicorn 得到如下的结果。 1234567891011121314151617181920212223242526|-grep,6194 --col gunicorn | `-gunicorn,30080 /usr/local/bin/gunicorn collect:app -c collect_gunicorn.py | |-gunicorn,4413 /usr/local/bin/gunicorn collect:app -c collect_gunicorn.py | |-gunicorn,8030 /usr/local/bin/gunicorn collect:app -c collect_gunicorn.py | |-gunicorn,8135 /usr/local/bin/gunicorn collect:app -c collect_gunicorn.py | |-gunicorn,8137 /usr/local/bin/gunicorn collect:app -c collect_gunicorn.py | |-gunicorn,11532 /usr/local/bin/gunicorn collect:app -c collect_gunicorn.py | |-gunicorn,13460 /usr/local/bin/gunicorn collect:app -c collect_gunicorn.py | |-gunicorn,19728 /usr/local/bin/gunicorn collect:app -c collect_gunicorn.py | |-gunicorn,23585 /usr/local/bin/gunicorn collect:app -c collect_gunicorn.py | |-gunicorn,23825 /usr/local/bin/gunicorn collect:app -c collect_gunicorn.py | |-gunicorn,27921 /usr/local/bin/gunicorn collect:app -c collect_gunicorn.py | |-gunicorn,28899 /usr/local/bin/gunicorn collect:app -c collect_gunicorn.py | |-gunicorn,28900 /usr/local/bin/gunicorn collect:app -c collect_gunicorn.py | |-gunicorn,28901 /usr/local/bin/gunicorn collect:app -c collect_gunicorn.py | |-gunicorn,35637 /usr/local/bin/gunicorn collect:app -c collect_gunicorn.py | |-gunicorn,36963 /usr/local/bin/gunicorn collect:app -c collect_gunicorn.py | |-gunicorn,43074 /usr/local/bin/gunicorn collect:app -c collect_gunicorn.py | |-gunicorn,43118 /usr/local/bin/gunicorn collect:app -c collect_gunicorn.py | |-gunicorn,43232 /usr/local/bin/gunicorn collect:app -c collect_gunicorn.py | |-gunicorn,43307 /usr/local/bin/gunicorn collect:app -c collect_gunicorn.py | |-gunicorn,43308 /usr/local/bin/gunicorn collect:app -c collect_gunicorn.py | |-gunicorn,44018 /usr/local/bin/gunicorn collect:app -c collect_gunicorn.py | |-gunicorn,46996 /usr/local/bin/gunicorn collect:app -c collect_gunicorn.py | |-gunicorn,47000 /usr/local/bin/gunicorn collect:app -c collect_gunicorn.py | `-gunicorn,47650 /usr/local/bin/gunicorn collect:app -c collect_gunicorn.py 很显然，30080就是Gunicorn的主进程。 2. 重启Gunicorn任务按照官方的推荐方法，很容易执行命令： 1kill -HUP 30080 执行上述命令后，再次执行“pstree -ap|grep gunicorn”，我们很容易发现，除了主进程，其他的Gunicorn进程都已经销毁，并新建了进程（进程ID发生了变化）。 3. 退出Gunicorn任务1kill -9 30080 转自:http://www.chenxm.cc/post/541.html?csdn]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>gunicorn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux每日命令(3)：ln命令]]></title>
    <url>%2F2018%2F10%2F23%2Flinux%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4(3)%EF%BC%9Aln%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[ln是linux中又一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接.当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。 1．命令格式：ln [参数][源文件或目录][目标文件或目录] 2．命令功能： Linux文件系统中，有所谓的链接(link)，我们可以将其视为档案的别名，而链接又可分为两种 : 硬链接(hard link)与软链接(symbolic link)，硬链接的意思是一个档案可以有多个名称，而软链接的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。硬链接是存在同一个文件系统中，而软链接却可以跨越不同的文件系统。 软链接： 软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式 软链接可以 跨文件系统 ，硬链接不可以 软链接可以对一个不存在的文件名进行链接 软链接可以对目录进行链接 软链接就相当于windows的的快捷方式，使用场景：1.在文件系统中多处共享同一个较大文件时，使用软链接就可以避免创建多个副本。2.维护动态库文件的版本时，使用软链接，在升级库文件后，只需修改软链接的源文件，而使用该库的程序则不需要修改。 使用原文件的绝对路径创建的软链接，不会随着软链接路径改动而失效！所以建议使用原文件绝对路径创建软链接。这时候的软链接才算得上是真正意义上相当于Windows的快捷方式，一旦生成处处可用 硬链接: 硬链接，以文件副本的形式存在。但不占用实际空间。 不允许给目录创建硬链接 硬链接只有在同一个文件系统中才能创建 硬链接说白了是一个指针，指向文件索引节点，系统并不为它重新分配inode。源文件和硬链接文件都是指向同一块磁盘空间的！通过使用硬链接可达到备份数据(实际是备份节点)的效果！ 注意：第一，ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化； 第二，ln的链接又分软链接和硬链接两种，软链接就是ln –s 源文件 目标文件，它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接 ln 源文件 目标文件，没有参数-s， 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。 ln指令用在链接文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则会把前面指定的所有文件或目录复制到该目录。若同时指定多个文件或目录，且最后的目的地并非是一个已存在的目录，则会出现错误信息。 3. 命令参数： 必要参数 描述 -b 删除，覆盖以前建立的链接 -d 允许超级用户制作目录的硬链接 -f 强制执行 -i 交互模式，文件存在则提示用户是否覆盖 -n 把符号链接视为一般目录 -s 软链接(符号链接) -v 显示详细的处理过程 选择参数 描述 -S “-S&lt;字尾备份字符串&gt; ”或 “–suffix=&lt;字尾备份字符串&gt;” -V “-V&lt;备份方式&gt;”或“–version-control=&lt;备份方式&gt;” –help 显示帮助信息 –version 显示版本信息 4. 常用示例1. 给2018.log创建一个名为link2018的软链接命令： ln -s 2018.log link2018 输出：123456789101112hc@hc-virtual-machine:~/PycharmProjects/my_test$ ls2018.loghc@hc-virtual-machine:~/PycharmProjects/my_test$ ln -s 2018.log link2018hc@hc-virtual-machine:~/PycharmProjects/my_test$ ls2018.log link2018hc@hc-virtual-machine:~/PycharmProjects/my_test$ ll总用量 12drwxrwxr-x 3 hc hc 4096 10月 23 11:53 ./drwxrwxr-x 6 hc hc 4096 10月 19 18:22 ../-rw-r--r-- 1 hc hc 0 10月 23 11:53 2018.logdrwxrwxr-x 2 hc hc 4096 10月 18 17:42 .idea/lrwxrwxrwx 1 hc hc 8 10月 23 11:53 link2018 -&gt; 2018.log 修改源文件2018.log内容，其软链接内容会同步修改123456789hc@hc-virtual-machine:~/PycharmProjects/my_test$ cat 2018.log 我是log日志hc@hc-virtual-machine:~/PycharmProjects/my_test$ cat link2018我是log日志hc@hc-virtual-machine:~/PycharmProjects/my_test$ vim 2018.log hc@hc-virtual-machine:~/PycharmProjects/my_test$ cat 2018.log 我是loghc@hc-virtual-machine:~/PycharmProjects/my_test$ cat link2018.log 我是log 说明： cat 命令是查看文件内容为2018.log文件创建软链接link2018，如果2018.log丢失，link2018将失效 2. 为2018.log 创建一个硬链接ln2018命令： ln 2018.log ln2018 输出：12345678910111213hc@hc-virtual-machine:~/PycharmProjects/my_test$ ls2018.log link2018hc@hc-virtual-machine:~/PycharmProjects/my_test$ ln 2018.log ln2018hc@hc-virtual-machine:~/PycharmProjects/my_test$ ls2018.log link2018 ln2018hc@hc-virtual-machine:~/PycharmProjects/my_test$ ll总用量 20drwxrwxr-x 3 hc hc 4096 10月 23 12:02 ./drwxrwxr-x 6 hc hc 4096 10月 19 18:22 ../-rw-r--r-- 2 hc hc 10 10月 23 11:57 2018.logdrwxrwxr-x 2 hc hc 4096 10月 18 17:42 .idea/lrwxrwxrwx 1 hc hc 8 10月 23 12:00 link2018 -&gt; 2018.log-rw-r--r-- 2 hc hc 10 10月 23 11:57 ln2018 说明： 为2018.log创建硬链接ln2018，2018.log与ln2018的各项属性相同 修改源文件2018.log内容，其软硬链接内容均会同步修改1234567891011hc@hc-virtual-machine:~/PycharmProjects/my_test$ cat ln2018 我是loghc@hc-virtual-machine:~/PycharmProjects/my_test$ cat 2018.log 我是loghc@hc-virtual-machine:~/PycharmProjects/my_test$ vim 2018.log hc@hc-virtual-machine:~/PycharmProjects/my_test$ cat 2018.log 我是log1hc@hc-virtual-machine:~/PycharmProjects/my_test$ cat ln2018 我是log1hc@hc-virtual-machine:~/PycharmProjects/my_test$ cat link2018 我是log1 3. 接上面两实例，链接完毕后，删除和重建链接原文件演示如下：1234567891011121314151617181920212223242526272829303132333435hc@hc-virtual-machine:~/PycharmProjects/my_test$ ls2018.log link2018 ln2018hc@hc-virtual-machine:~/PycharmProjects/my_test$ ll总用量 20drwxrwxr-x 3 hc hc 4096 10月 23 12:04 ./drwxrwxr-x 6 hc hc 4096 10月 19 18:22 ../-rw-r--r-- 2 hc hc 11 10月 23 12:04 2018.logdrwxrwxr-x 2 hc hc 4096 10月 18 17:42 .idea/lrwxrwxrwx 1 hc hc 8 10月 23 12:00 link2018 -&gt; 2018.log-rw-r--r-- 2 hc hc 11 10月 23 12:04 ln2018hc@hc-virtual-machine:~/PycharmProjects/my_test$ rm -rf 2018.log hc@hc-virtual-machine:~/PycharmProjects/my_test$ ll总用量 16drwxrwxr-x 3 hc hc 4096 10月 23 12:57 ./drwxrwxr-x 6 hc hc 4096 10月 19 18:22 ../drwxrwxr-x 2 hc hc 4096 10月 18 17:42 .idea/lrwxrwxrwx 1 hc hc 8 10月 23 12:00 link2018 -&gt; 2018.log-rw-r--r-- 1 hc hc 11 10月 23 12:04 ln2018hc@hc-virtual-machine:~/PycharmProjects/my_test$ touch 2018.loghc@hc-virtual-machine:~/PycharmProjects/my_test$ ll总用量 16drwxrwxr-x 3 hc hc 4096 10月 23 12:57 ./drwxrwxr-x 6 hc hc 4096 10月 19 18:22 ../-rw-r--r-- 1 hc hc 0 10月 23 12:57 2018.logdrwxrwxr-x 2 hc hc 4096 10月 18 17:42 .idea/lrwxrwxrwx 1 hc hc 8 10月 23 12:00 link2018 -&gt; 2018.log-rw-r--r-- 1 hc hc 11 10月 23 12:04 ln2018hc@hc-virtual-machine:~/PycharmProjects/my_test$ vim 2018.log hc@hc-virtual-machine:~/PycharmProjects/my_test$ cat 2018.log 2018log日志hc@hc-virtual-machine:~/PycharmProjects/my_test$ cat link2018 2018log日志hc@hc-virtual-machine:~/PycharmProjects/my_test$ cat ln2018 我是log1hc@hc-virtual-machine:~/PycharmProjects/my_test$ 说明： 源文件被删除后，并没有影响硬链接文件；软链接文件在centos系统下不断的闪烁，提示源文件已经不存在 重建源文件后，软链接不在闪烁提示，说明已经链接成功，找到了链接文件系统；重建后，硬链接文件并没有受到源文件影响，硬链接文件的内容还是保留了删除前源文件的内容，说明硬链接已经失效 4. 将文件链接到目录中演示如下：1234567891011121314151617181920212223242526272829hc@hc-virtual-machine:~/PycharmProjects/my_test$ ls2018.log link2018 ln2018hc@hc-virtual-machine:~/PycharmProjects/my_test$ mkdir testhc@hc-virtual-machine:~/PycharmProjects/my_test$ ls2018.log link2018 ln2018 testhc@hc-virtual-machine:~/PycharmProjects/my_test$ ln 2018.log testhc@hc-virtual-machine:~/PycharmProjects/my_test$ ls2018.log link2018 ln2018 testhc@hc-virtual-machine:~/PycharmProjects/my_test$ cd test/hc@hc-virtual-machine:~/PycharmProjects/my_test/test$ ls2018.loghc@hc-virtual-machine:~/PycharmProjects/my_test/test$ vi 2018.log hc@hc-virtual-machine:~/PycharmProjects/my_test/test$ cat 2018.log 2018log日志,加1hc@hc-virtual-machine:~/PycharmProjects/my_test/test$ cd ..hc@hc-virtual-machine:~/PycharmProjects/my_test$ ls2018.log link2018 ln2018 testhc@hc-virtual-machine:~/PycharmProjects/my_test$ cat 2018.log 2018log日志,加1hc@hc-virtual-machine:~/PycharmProjects/my_test$ ll总用量 24drwxrwxr-x 4 hc hc 4096 10月 23 13:31 ./drwxrwxr-x 7 hc hc 4096 10月 23 13:30 ../-rw-r--r-- 2 hc hc 19 10月 23 13:32 2018.logdrwxrwxr-x 2 hc hc 4096 10月 18 17:42 .idea/lrwxrwxrwx 1 hc hc 8 10月 23 12:00 link2018 -&gt; 2018.log-rw-r--r-- 1 hc hc 11 10月 23 12:04 ln2018drwxr-xr-x 2 hc hc 4096 10月 23 13:32 test/hc@hc-virtual-machine:~/PycharmProjects/my_test$ 说明： 在test目录中创建了2018.log的硬链接，修改test目录中的2018.log文件，同时也会同步到源文件 5：给目录创建软链接命令： ln -sv 源目录 目标目录 演示如下：12345678910111213141516171819202122232425262728293031323334353637383940hc@hc-virtual-machine:~/PycharmProjects$ ll总用量 28drwxrwxr-x 7 hc hc 4096 10月 23 13:30 ./drwxr-xr-x 23 hc hc 4096 10月 23 13:32 ../drwxr-xr-x 9 hc hc 4096 10月 22 15:25 FreshOnline/drwxrwxr-x 6 hc hc 4096 10月 19 19:07 FreshOnline_env/drwxrwxr-x 4 hc hc 4096 10月 23 13:31 my_test/drwxrwxr-x 4 hc hc 4096 10月 23 11:52 py3_test/drwxr-xr-x 2 hc hc 4096 10月 23 13:30 test/hc@hc-virtual-machine:~/PycharmProjects$ ln -sv /home/hc/PycharmProjects/my_test /home/hc/PycharmProjects/test'/home/hc/PycharmProjects/test/my_test' -&gt; '/home/hc/PycharmProjects/my_test'hc@hc-virtual-machine:~/PycharmProjects$ ll总用量 28drwxrwxr-x 7 hc hc 4096 10月 23 13:30 ./drwxr-xr-x 23 hc hc 4096 10月 23 13:32 ../drwxr-xr-x 9 hc hc 4096 10月 22 15:25 FreshOnline/drwxrwxr-x 6 hc hc 4096 10月 19 19:07 FreshOnline_env/drwxrwxr-x 4 hc hc 4096 10月 23 13:31 my_test/drwxrwxr-x 4 hc hc 4096 10月 23 11:52 py3_test/drwxr-xr-x 2 hc hc 4096 10月 23 13:38 test/hc@hc-virtual-machine:~/PycharmProjects$ cd my_test/hc@hc-virtual-machine:~/PycharmProjects/my_test$ ls2018.log link2018 ln2018 testhc@hc-virtual-machine:~/PycharmProjects/my_test$ cd ..hc@hc-virtual-machine:~/PycharmProjects$ lsFreshOnline FreshOnline_env my_test py3_test testhc@hc-virtual-machine:~/PycharmProjects$ cd test/hc@hc-virtual-machine:~/PycharmProjects/test$ lsmy_testhc@hc-virtual-machine:~/PycharmProjects/test$ cd my_testhc@hc-virtual-machine:~/PycharmProjects/test/my_test$ ls2018.log link2018 ln2018 testhc@hc-virtual-machine:~/PycharmProjects/test/my_test$ cd ..hc@hc-virtual-machine:~/PycharmProjects/test$ lsmy_testhc@hc-virtual-machine:~/PycharmProjects/test$ ll总用量 8drwxr-xr-x 2 hc hc 4096 10月 23 13:38 ./drwxrwxr-x 7 hc hc 4096 10月 23 13:30 ../lrwxrwxrwx 1 hc hc 32 10月 23 13:38 my_test -&gt; /home/hc/PycharmProjects/my_test/ 说明： 目录只能创建软链接 目录创建链接必须用绝对路径，相对路径创建会不成功，会提示：符号连接的层数过多 这样的错误 使用原文件的绝对路径创建的软链接，不会随着软链接路径改动而失效！所以建议使用原文件绝对路径创建软链接。这时候的软链接才算得上是真正意义上相当于Windows的快捷方式，一旦生成处处可用 在链接目标目录中修改文件都会在源文件目录中同步变化]]></content>
      <categories>
        <category>linux每日命令</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux每日命令(2)：cd命令]]></title>
    <url>%2F2018%2F10%2F22%2Flinux%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4(2)%EF%BC%9Acd%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1.命令格式：cd [目录名] 2.命令功能切换当前目录至 [目录名] 3. 常用范例1.进入系统根目录命令： cd / 说明：进入系统根目录,上面命令执行完后拿ls命令看一下，当前目录已经到系统根目录了 输出：1234567hc@hc-virtual-machine:~$ pwd/home/hchc@hc-virtual-machine:~$ cd /hc@hc-virtual-machine:/$ lsbin dev initrd.img lib64 mnt root snap sys varboot etc initrd.img.old lost+found opt run srv tmp vmlinuzcdrom home lib media proc sbin swapfile usr pwd的作用是查询当前所在目录 2. 返回父级目录命令： cd .. 输出： 12345hc@hc-virtual-machine:~/PycharmProjects$ pwd/home/hc/PycharmProjectshc@hc-virtual-machine:~/PycharmProjects$ cd ..hc@hc-virtual-machine:~$ pwd/home/hc 3.进入当前目录的父目录的父目录命令： cd ../.. 输出： 12345hc@hc-virtual-machine:~/PycharmProjects$ pwd/home/hc/PycharmProjectshc@hc-virtual-machine:~/PycharmProjects$ cd ../..hc@hc-virtual-machine:/home$ pwd/home 4. 进入当前用户主目录 “当前用户主目录”和“系统根目录”是两个不同的概念。进入当前用户主目录有两个方法。 命令1： cd 直接输入cd，然后回车 输出：12345hc@hc-virtual-machine:~/PycharmProjects/my_test$ pwd/home/hc/PycharmProjects/my_testhc@hc-virtual-machine:~/PycharmProjects/my_test$ cd hc@hc-virtual-machine:~$ pwd/home/hc 上面的命令是我在非root用户下操作的，现在我切换到root用户下再操作一遍 123456hc@hc-virtual-machine:~/PycharmProjects/my_test$ sudo suroot@hc-virtual-machine:/home/hc/PycharmProjects/my_test# pwd/home/hc/PycharmProjects/my_testroot@hc-virtual-machine:/home/hc/PycharmProjects/my_test# cd root@hc-virtual-machine:~# pwd/root 命令2： cd ~ 输出12345hc@hc-virtual-machine:~/PycharmProjects/my_test$ pwd/home/hc/PycharmProjects/my_testhc@hc-virtual-machine:~/PycharmProjects/my_test$ cd ~hc@hc-virtual-machine:~$ pwd/home/hc 5. 跳转到指定目录命令 cd /home/hc/PycharmProjects/my_test/ 输出12345hc@hc-virtual-machine:/$ pwd/hc@hc-virtual-machine:/$ cd /home/hc/PycharmProjects/my_test/hc@hc-virtual-machine:~/PycharmProjects/my_test$ pwd/home/hc/PycharmProjects/my_test 6.返回进入此目录之前所在的目录命令： cd - 说明：自动跳转到进入此目录之前所在的目录，并输出所在目录名称 输出：123456789hc@hc-virtual-machine:/$ pwd/hc@hc-virtual-machine:/$ cd /home/hc/PycharmProjects/my_test/hc@hc-virtual-machine:~/PycharmProjects/my_test$ pwd/home/hc/PycharmProjects/my_testhc@hc-virtual-machine:~/PycharmProjects/my_test$ cd -/hc@hc-virtual-machine:/$ pwd/ 7. 把上个命令的参数作为cd参数使用命令： cd !$ 输出:12345678hc@hc-virtual-machine:~/PycharmProjects/my_test$ pwd/home/hc/PycharmProjects/my_testhc@hc-virtual-machine:~/PycharmProjects/my_test$ ls /opt/googlehc@hc-virtual-machine:~/PycharmProjects/my_test$ cd !$cd /opt/hc@hc-virtual-machine:/opt$ pwd/opt]]></content>
      <categories>
        <category>linux每日命令</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux每日命令(1)：ls命令]]></title>
    <url>%2F2018%2F10%2F20%2Flinux%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4(1)%EF%BC%9Als%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[ls命令是linux下最常用的命令。ls命令就是list的缩写缺省下ls用来打印出当前目录的清单如果ls指定其他目录那么就会显示指定目录里的文件及文件夹清单。 通过ls 命令不仅可以查看linux文件夹包含的文件而且可以查看文件权限(包括目录、文件夹、文件权限)查看目录信息等等。ls 命令在日常的linux操作中用的很多! 1.命令格式：ls [选项] [目录名] 2.命令功能列出目标目录中所有的子目录和文件。（不包含.开头的文件） 3.常用选项参数 选项参数 作用 -l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来。 -g 类似 -l,但不列出所有者 -o 类似 -l,显示文件的除组信息外的详细信息。 -a 列出目录下的所有文件，包括以 . 开头的文件 -A 同-a，但不列出“.”(表示当前目录)和“..”(表示当前目录的父目录)。 -F 使得ls命令可以在显示子目录的时候在它的文件名之后加上一个斜线(“/”)字符。而文件后面的星号(“*”)字符表示这是一个可执行程序 -r –reverse 依相反次序排列 -R –recursive 同时列出所有子目录层 -t 以文件修改时间排序 -S 根据文件大小排序 -c 根据 ctime(文件状态最后更改的时间) 排序；配合 -l：显示 ctime 但根据名称排序否则：根据 ctime 排序；配合-lt:根据 ctime 排序及显示 ctime -u 配合 -lt:显示访问时间而且依访问时间排序；配合 -l:显示访问时间但根据名称排序；否则：根据访问时间排序 -U 不进行排序;依文件系统原有的次序列出项目 -v 根据版本进行排序 -h 以容易理解的格式列出文件大小 (例如 1K 234M 2G) –si 类似 -h,但文件大小取 1000 的次方而不是 1024 -k 以 k 字节的形式表示文件的大小。 -s 以块大小为单位列出所有文件的大小 -m 所有项目以逗号分隔，并填满整行行宽 -w 自行指定屏幕宽度而不使用目前的数值 -x 逐行列出项目而不是逐栏列出 -X 根据扩展名排序 -1 每行只列出一个文件 –help 显示此帮助信息并离开 –version 显示版本信息并离开 4.常见范例1：列出/home/hc文件夹下的所有文件和目录的详细资料命令1 ls -l -R /home/hc 在使用 ls 命令时要注意命令的格式：在命令提示符后，首先是命令的关键字，接下来是命令参数，在命令参数之前要有一短横线“-”，所有的命令参数都有特定的作用，自己可以根据需要选用一个或者多个参数，在命令参数的后面是命令的操作对象。在以上这条命令“ ls -l -R /home/hc”中，“ls” 是命令关键字，“-l -R”是参数，“ /home/hc”是命令的操作对象。在这条命令中，使用到了两个参数，分别为“l”和“R”，当然，你也可以把他们放在一起使用，如下所示： 命令2 ls -lR /home/hc 这种形式和上面的命令形式执行的结果是完全一样的。另外，如果命令的操作对象位于当前目录中，可以直接对操作对象进行操作;如果不在当前目录则需要给出操作对象的完整路径，例如上面的例子中，我的当前文件夹是hc文件夹，我想对home文件夹下的hc文件进行操作，我可以直接输入 ls -lR hc，也可以用 ls -lR /home/hc。 2：列出当前目录中所有以“t”开头的目录的详细内容，可以使用如下命令：命令： ls -l t* 可以查看当前目录下文件名以“t”开头的所有文件的信息。其实，在命令格式中，方括号内的内容都是可以省略的，对于命令ls而言，如果省略命令参数和操作对象，直接输入“ ls ”，则将会列出当前工作目录的内容清单。 3：只列出文件下的子目录列出 /home/hc/PycharmProjects 文件下面的子目录命令： ls -F /home/hc/PycharmProjects |grep /$ 输出： 12345hc@hc-virtual-machine:~$ ls -F /home/hc/PycharmProjects |grep /$FreshOnline/FreshOnline_env/my_test/py3_test/ 列出 /home/hc/PycharmProjects 文件下面的子目录详细情况 命令： ls -l /home/hc/PycharmProjects | grep &quot;^d&quot; 输出： 12345hc@hc-virtual-machine:~$ ls -l /home/hc/PycharmProjects | grep "^d"drwxr-xr-x 9 hc hc 4096 10月 20 08:56 FreshOnlinedrwxrwxr-x 6 hc hc 4096 10月 19 19:07 FreshOnline_envdrwxrwxr-x 3 hc hc 4096 10月 18 15:24 my_testdrwxrwxr-x 4 hc hc 4096 10月 18 17:58 py3_test 4：列出目前工作目录下所有名称是s 开头的档案，愈新的排愈后面，可以使用如下命令：命令： ls -ltr s* 输出：1234hc@hc-virtual-machine:~$ ls -ltr s*总用量 8drwxr-xr-x 5 hc hc 4096 9月 28 21:28 gnome-system-monitordrwxr-xr-x 4 hc hc 4096 9月 29 08:39 pycharm-professional 5：列出目前工作目录下所有档案及目录;目录于名称后加”/“, 可执行档于名称后加”*”命令： ls -AF 输出： 12hc@hc-virtual-machine:~/PycharmProjects$ ls -AFFreshOnline/ FreshOnline_env/ my_test/ py3_test/ 6：计算当前目录下的文件数和目录数命令： ls -l * |grep &quot;^-&quot;|wc -l ---文件个数 ls -l * |grep &quot;^d&quot;|wc -l ---目录个数 7: 在ls中列出文件的绝对路径命令： ls | sed &quot;s:^:`pwd`/:&quot; 输出： 12345hc@hc-virtual-machine:~/PycharmProjects$ ls | sed "s:^:`pwd`/:"/home/hc/PycharmProjects/FreshOnline/home/hc/PycharmProjects/FreshOnline_env/home/hc/PycharmProjects/my_test/home/hc/PycharmProjects/py3_test 8：列出当前目录下的所有文件（包括隐藏文件）的绝对路径， 对目录不做递归命令： find $PWD -maxdepth 1 | xargs ls -ld 输出： 123456hc@hc-virtual-machine:~/PycharmProjects$ find $PWD -maxdepth 1 | xargs ls -lddrwxrwxr-x 6 hc hc 4096 10月 19 18:22 /home/hc/PycharmProjectsdrwxr-xr-x 9 hc hc 4096 10月 20 08:56 /home/hc/PycharmProjects/FreshOnlinedrwxrwxr-x 6 hc hc 4096 10月 19 19:07 /home/hc/PycharmProjects/FreshOnline_envdrwxrwxr-x 3 hc hc 4096 10月 18 15:24 /home/hc/PycharmProjects/my_testdrwxrwxr-x 4 hc hc 4096 10月 18 17:58 /home/hc/PycharmProjects/py3_test 9：递归列出当前目录下的所有文件（包括隐藏文件）的绝对路径命令： find $PWD | xargs ls -ld 10：指定文件时间输出格式命令： ls -tl --time-style=full-iso 输出：123456hc@hc-virtual-machine:~/PycharmProjects$ ls -tl --time-style=full-iso总用量 16drwxr-xr-x 9 hc hc 4096 2018-10-20 08:56:55.833765666 +0800 FreshOnlinedrwxrwxr-x 6 hc hc 4096 2018-10-19 19:07:08.330876787 +0800 FreshOnline_envdrwxrwxr-x 4 hc hc 4096 2018-10-18 17:58:39.489690632 +0800 py3_testdrwxrwxr-x 3 hc hc 4096 2018-10-18 15:24:06.613354334 +0800 my_test ls -ctl --time-style=long-iso 输出： 123456hc@hc-virtual-machine:~/PycharmProjects$ ls -ctl --time-style=long-iso总用量 16drwxr-xr-x 9 hc hc 4096 2018-10-20 08:56 FreshOnlinedrwxrwxr-x 6 hc hc 4096 2018-10-19 19:07 FreshOnline_envdrwxrwxr-x 4 hc hc 4096 2018-10-18 17:58 py3_testdrwxrwxr-x 3 hc hc 4096 2018-10-18 15:24 my_test 扩展：显示彩色目录列表打开/etc/bashrc, 加入如下一行: alias ls=&quot;ls --color&quot; 下次启动bash时就可以像在Slackware里那样显示彩色的目录列表了, 其中颜色的含义如下: 1. 蓝色--&gt;目录 2. 绿色--&gt;可执行文件 3. 红色--&gt;压缩文件 4. 浅蓝色--&gt;链接文件 5. 灰色--&gt;其他文件]]></content>
      <categories>
        <category>linux每日命令</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用命令大全]]></title>
    <url>%2F2018%2F08%2F31%2Fgit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[记录日常工作中常用git命令，以便备忘查询 初始化git仓库 git initgit init 添加文件到Git仓库 git add 、 git commit分两步： 第一步，使用命令git add 文件名 ，将指定文件添加到版本库的暂存状态。注意，可反复多次使用，添加多个文件；也可以直接 git add . 代表添加所有改变的文件 第二步，使用命令 git commit -m &#39;自定义的提交说明&#39; 将暂存区的文件提交到版本库的分支 我们需要知道Git把管理的文件分为了两个区域四个状态 工作区：当前开发程序所在目录称为工作区，即：工作开发都是在该目录，该区域的文件会有状态的变化且状态由git自动检测，如果程序中文件做任何操作（增、删、改），文件状态均会被检测到，可以使用 【git status】命令查看。 版本库 工作区检测到有文件发生变化，那么意味着较上一个版本之后对程序进行了修改，修改完成之后，可以当做下一版本进行提交，那么就是执行 【git add .】 将所有文件提交到暂存区，然后再执行【git commit -m ‘又一个版本’】提交到版本库的分支即可，之后可以使用【git log】命令查看版本记录。 查看当前仓库状态 git status我们可以用 git status 来查看当前Git仓库状态,如：那些文件被修改过、那些文件还未提交到版本库等。 查看提交的版本记录 git log、 git refloggit log， 命令显示从最近到最远的提交日志，即：历史版本记录 git reflog，用来查看执行回退命令后，在 git log中未显示的记录 查看修改内容 git diff假设我们已经成功地添加并提交了一个readme.txt文件，现在，继续工作了，我们继续修改readme.txt文件 此时，我们使用git status 命令， 可以发现readme.txt文件已经被修改了，但还未提交，但是具体修改了什么，我们无法得知，加入我们此时将其放置，一两周后再回来看，可能会不记得之前改动了什么，此时我们可以使用 git diff readme.txt 来查看readme.txt 文件里修改的内容确定了我们修改了什么内容以后，我们就可以放心大胆的git add . 然后git commit -m&#39;修改readme.txt&#39; 提交此次修改了 要随时掌握工作区的状态，使用 git status 命令。•如果 git status 告诉你有文件被修改过，用 git diff 可以查看修改内容。 版本回退在Git中，用HEAD表示当前版本，也就是最新的提交版），上一个版本就是HEAD^ ，上上一个版本就是HEAD^^，当然往上100 个版本写100个^比较容易数不过来，所以写成HEAD~100。 比如当前版本id为4,我们想跳到上一个版本3去，可以使用下面的命令 回退到上一个版本 git reset --hard HEAD^git reset --hard HEAD^ 或直接指定具体版本 git reset --hard 3 回退到具体版本 git reset --hard commit_id一旦我们执行了回退操作，则 git log中将看不到当前回退到的版本之后的所有版本信息 要想在回退后，看到当前版本之后的信息需要用到git reflog 如果现在又想跳回去，可以使用git reset --hard 4 小结 HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令 git reset --hard commit_id 。 穿梭前，用 git log 可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用 git reflog 查看命令历史，以便确定要回到未来的哪个版本。 撤销工作区的修改git checkout --文件名有时我们不小心写了很多无用的东西，想丢弃工作区的修改，可以使用git checkout --文件名 命令 git checkout -- readme.txt 意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况： 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。总之，就是让这个文件回到最近一次 git commit 或 git add 时的状态 当我们工作区中的内容不小心 git add 了（但是没有git commit），进入了暂存区时，此时要想撤销修改，则需要用到下面的命令 撤销暂存区的修改 git reset HEAD 文件名用命令 git reset HEAD file 可以把暂存区的修改撤销掉（unstage），重新放回工作区：git reset 命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。再用 git status 查看一下，现在暂存区是干净的，工作区有修改还记得如何丢弃工作区的修改吗？git checkout -- 文件名 此时再用 git status，则是干净的 重新编辑最近一次git commit -m 里写的注释备注内容命令： git commit --amend 如果git commit 后发现commit的信息写错了或者是有的文件忘记提交，并且commit后没有进行过push，可以通过git commit --amend 来对本次commit进行修改 123git commit -m 'initial commit'git add ./README.mdgit commit --amend 上面的三条命令最终只是产生一个提交，第二个提交命令修正了第一个的提交内容。 小结 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令 git checkout -- file。 场景2：当你不但改乱了工作区某⽂文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令 git reset HEAD file ，就回到了场景1，第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，则使用git reset --hard commit_id，不过前提是没有推送到远程库。 删除文件 git rm 在Git中，删除也是一个修改操作,当我们直接在文件管理器中删除git仓库所在目录下的文件，或者直接通过rm 文件名来删除某个文件时，git会将其认定为一个修改操作，这样会造成工作区和版本库中不一致，此时有两种情况，根据我们的需求来进行选择 情况1：如果我们确实是想从版本库中删除该文件，那么就用git rm 文件名 命令来进行删除，然后 git commit -m&#39;删除某文件&#39; ，提交此次删除，这样，该文件就从版本库中被删除了 情况2: 不小心误删了，由于版本库中还存在，我们可以直接将误删的文件恢复到版本库中该文件的最新版本，使用命令git checkout -- 文件名,git checkout 其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。但是需要注意的是：这种方法只能恢复文件到最新版本，但会丢失最近一次提交后你修改的内容。 分支管理创建分支 git branch 分支名切换分支 git checkout 分支名也可以直接使用一条命令，来完成上面两个命令的操作 创建并切换分支 git checkout -b 分支名查看当前所属分支 git branchgit branch 命令会列出所有分支，当前分支前面会标一个*号。 合并分支 git merge 分支名比如：我们当前所在分支为master，我们要想将dev分支中的内容合并到master中来，就在master分支下，使用命令 git merge dev 即可 git merge 命令用于合并指定分支到当前分支。合并后，就可以看到，当前master分支和dev分支的最新提交是完全一样的。 注意到,默认情况下,git会采用Fast-forward方式进行合并，即“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。当然，也不是每次合并都能Fast-forward（比如当我们合并时产生了冲突，需要解决冲突时，就无法使用”快进模式”了） 解决合并冲突之所以合并产生冲突，是因为我们进行合并时，我们的合并分支在我们准备合并前已发生变化（大多数情况下，是由于协同开发时，由于别人在我们进行合并之前，先进行了合并操作，导致我们再去合并时，已经发生了变化），因此我们需要根据冲突提升，找出冲突所在地，去解决冲突，在冲突文件中，Git用 &lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们需要对比找出需要删除和保留的代码，最后再将&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;这些符号删除，然后git add . ,git commit -m&#39;解决冲突&#39; ，即合并完成。 合并分支时，可禁用”Fast forward”模式 git merge --no-ff -m &quot;提交信息&quot; 分支名通常，合并分支时，如果可能，Git会用“Fast forward”模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用“Fast forward”模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。--no-ff 参数，表示禁用“Fast forward”,因为禁用了“快速模式”，合并时要创建一个新的commit，所以加上-m参数，把commit描述写进去。 删除分支 git branch -d 分支名如果要丢弃一个没有被合并过的分支，可以通过 git branch -D 分支名 强行删除。 查看分支合并图 git log --graphBug 分支 在我们日常开发中，经常会遇到开发途中，遇到需要修复之前BUG的需求，很自然地，我们会到想创建一个分支来修复它，但是，当前正在dev上进行的工作还没有提交，并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？无法创建新的分支，怎么办？幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作： “暂存”工作区中的代码 git stash使用命令git stash 后，我们当前工作区的代码将被暂存起来（并不是git add 命令存入的那个暂存区）， 这时用 git status 查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。首先确定要在哪个支上修复bug，假定需要在master分支上修复，就从master创建临时分支： 切换分支git checkout master 创建并切换bug分支git checkout -b bug01 git add . 、git commit -m&#39;修复bug01&#39;修复完成后 切换到master分支，并完成合并，最后删除bug01分支： git checkout master git merge --no-ff -m &quot;合并bug1分支&quot; bug01 git branch -d bug01 OK! bug修复完成，是时候切换回dev分支接着干活了 git checkout dev git status通过查看状态发现，我们当前工作区是干净的，我们在修复bug之前写的代码去哪了？我们之前用 git stash把工作区的内容存在某个地方了，现在可以通过命令查看stash记录 查看stash记录 git stash list现在我们要把之前暂存的内容恢复回来，有两种方式 恢复stash内容 一是用 git stash apply 恢复，但是恢复后，stash内容并不删除，你需要用git stash drop 来删除； 另一种方式是用 git stash pop ，恢复的同时把stash内容也删了： 再用 git stash list查看，就看不到任何stash内容了 我们可以多次stash，恢复的时候，先用 git stash list 查看，然后恢复指定的stash，用命令： git stash apply stash@{id} 小结修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；当手头工作没有完成时，先把⼯工作现场 git stash一下，然后去修复bug，修复后，再 gitstash pop ，回到工作现场。 远程仓库git多账号登陆问题设置git全局设置：git config --global user.name &quot;your_name&quot; git config --global user.email &quot;your_email&quot; 需要取消git的全局设置:git config --global --unset user.name git config --global --unset user.email 针对每个项目，单独设置用户名和邮箱，设置方法如下：git config user.name &quot;your_name&quot; git config user.email &quot;your_email&quot; 绑定远程仓库地址 要关联一个远程库，使用命令 git remote add origin 远程仓库地址（如：git@server-name:path/repo-name.git） ；关联后，使用命令 git push -u origin master 第一次推送master分⽀的所有内容；此后，每次本地提交后，只要有必要，就可以使用命令git push origin master 推送最新修改。 从远程库克隆要克隆一个仓库，首先必须知道仓库的地址，然后使用 git clone 远程库地址进行克隆。Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。 Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。 其他常用操作 查看远程库信息，使用 git remote -v； 本地新建的分支如果不推送到远程，对其他人就是不可见的； 从本地推送分支，使用 git push origin 分支名 ，如果推送失败，先用git pull orign 分支名抓取远程的新提交； 在本地创建和远程分支对应的分支，使用 git checkout -b 分支名 origin/分支名，本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联，使用 git branch --set-upstream 分支名 origin/分支名 ； 从远程抓取分支，使用git pull ，如果有冲突，要先处理冲突。 参考：Git教程]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows10环境下安装RabbitMQ(图文步骤)]]></title>
    <url>%2F2018%2F07%2F31%2Fwindows10%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85RabbitMQ(%E5%9B%BE%E6%96%87%E6%AD%A5%E9%AA%A4)%2F</url>
    <content type="text"><![CDATA[记录下本人在win10环境下安装RabbitMQ的步骤，以作备忘。 第一步：下载并安装erlang 原因：RabbitMQ服务端代码是使用并发式语言Erlang编写的，安装Rabbit MQ的前提是安装Erlang。 下载地址：http://www.erlang.org/downloads 根据本机位数选择erlang下载版本。 下载完是这么个东西： 双击，点next就可以。 选择一个自己想保存的地方，然后next、finish就可以。 安装完事儿后要记得配置一下系统的环境变量。此电脑–&gt;鼠标右键“属性”–&gt;高级系统设置–&gt;环境变量–&gt;“新建”系统环境变量 变量名：ERLANG_HOME 变量值就是刚才erlang的安装地址，点击确定。 然后双击系统变量path 点击“新建”，将%ERLANG_HOME%\bin加入到path中。 最后windows键+R键，输入cmd，再输入erl，看到版本号就说明erlang安装成功了。 第二步：下载并安装RabbitMQ 下载地址：http://www.rabbitmq.com/download.html 双击下载后的.exe文件，安装过程与erlang的安装过程相同。 RabbitMQ安装好后接下来安装RabbitMQ-Plugins。打开命令行cd，输入RabbitMQ的sbin目录 我的目录是：D:\Program Files\RabbitMQ Server\rabbitmq_server-3.7.3\sbin 然后在后面输入enable rabbitmq_management```命令进行安装1234567如果```rabbitmq-plugins enable rabbitmq_management```使用报错如下 ![](http://pcqah8keq.bkt.clouddn.com/13.png) 请请使用```rabbitmq-plugins.bat enable rabbitmq_management 安装成功如下： 打开sbin目录，双击rabbitmq-server.bat 等几秒钟看到这个界面后，访问http://localhost:15672 然后可以看到如下界面 默认用户名和密码都是guest 登陆即可。 转自：https://blog.csdn.net/weixin_39735923/article/details/79288578]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python unicode和str拼接报错原因]]></title>
    <url>%2F2018%2F07%2F25%2FPython%20unicode%E5%92%8Cstr%E6%8B%BC%E6%8E%A5%E6%8A%A5%E9%94%99%E5%8E%9F%E5%9B%A0%2F</url>
    <content type="text"><![CDATA[首先来看一段代码 一、例子 123456789101112131415161718192021222324# -*- coding: utf-8 -*-a1 = u'你好'b1 = '中文' print(a1+b1) # 报错a2 = u'你好'b2 = '中文' + a.encode('utf-8')print(b2) # 正常输出type(b2) # stra3 = u'http'b3 = 'abc' + aprint(b3) # 正常输出type(b3) # unicode a1,a2,a3都是unicode对象，unicode是一种编码标准，具体的实现可能是utf-8，utf-16，gbk等等，这就是中文字符串和unicode有密切关系的原因。python内部使用两个字节存储一个unicode对象（unicode对象并不只能是字符串，这两个字节还可以存其他内容），为什么要用unicode而不用str呢，因为中文转码的缘故，因为unicode的优点是便于跨平台。 b1 是str对象，中文字符串。存储方式是字节码。字节码是怎么存的：如果这行代码在python解释器中输入&amp;运行，那么s的格式就是解释器的编码格式；如果这行代码是在源码文件中写入、保存然后执行，那么解释器载入代码时就将s初始化为文件指定编码(比如py文件开头那行的utf-8)； 下面这两种方式都是表示unicode对象 12s1 = u'中文' # s1: &lt;type 'unicode'&gt;s2 = unicode('中文', 'utf-8') # utf8是在指定解码方式, s2: &lt;type 'unicode'&gt; python解释器中 如果 将一个 普通字符串 和 unicode对象字符串 拼接，会默认将普通字符串 用decode(‘ascii’)解码成unicode对象。为什么是用 ascii的方式解码呢，因为这里用的是python的默认编码,也就是defaultencoding = ascii。 所以，如果这个普通字符串 包含中文的话，就会报错，因为用ascii码去解码中文是不够用的。(中文得用unicode解码)。 二、正确的str对象和unicode对象拼接方式只要注意正确的decode、encode方式，统一编码后就能顺利地拼接了。123456789101112# -*- coding: utf-8 -*- s1 = '中文's2 = u'你好'print s1 + unicode(s2, 'utf-8') # 中文你好print s1 + s2.decode('utf-8') # 中文你好print s1.encode('utf-8') + s2 # 中文你好 print type(s1) # &lt;type 'str'&gt;print type(s2) # &lt;type 'unicode'&gt;print type(s1.decode('utf-8')) # &lt;type 'unicode'&gt;print type(s2.encode('utf-8')) # &lt;type 'str'&gt; 对于str要注意当前环境编码方式，也许是控制台那种设定好了的，也许是你自己在代码中指定的。对于unicode对象，一般都是decode得到的，像直接【u’你好’】这种其实不是很常见，所以要注意字符串来源是什么编码，比如从gbk文件或utf8文件中读入的。 参考自： https://blog.csdn.net/index20001/article/details/78974814 https://blog.csdn.net/qq_31739317/article/details/75257726]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python时间格式转换(时间戳、日期、时间、字符串)]]></title>
    <url>%2F2018%2F07%2F24%2FPython%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2(%E6%97%B6%E9%97%B4%E6%88%B3%E3%80%81%E6%97%A5%E6%9C%9F%E3%80%81%E6%97%B6%E9%97%B4%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2)%2F</url>
    <content type="text"><![CDATA[在工作中我们常会对时间戳以及日期时间等格式进行转换，下面介绍了一些常用的Python时间的转换方法，方便以后查询 一、str类型的日期转换为时间戳1234567891011121314# -*- coding: utf-8 -*-import timefrom datetime import datetimetss1 = '2013-10-10 23:40:00'# 转为时间数组timeArray = time.strptime(tss1, "%Y-%m-%d %H:%M:%S")# timeArray可以调用tm_year等print timeArray # time.struct_time# 转为时间戳timeStamp = int(time.mktime(timeArray))print timeStamp # 1381419600 二、时间戳转换:10位（秒级）和13位（毫秒级）时间戳123456789101112131415161718# -*- coding: utf-8 -*-import timefrom datetime import datetimenow_timestamp = time.time()print 'now_timestamp', now_timestamp, type(now_timestamp)# now_timestamp 1532447792.62 &lt;type 'float'&gt;seconds = int(now_timestamp)print '10位秒级', seconds# 10位秒级 1532447792millis1 = int(round(now_timestamp * 1000))print '13位毫秒级1', millis1, type(millis1)# 13位毫秒级1 1532447792615 &lt;type 'long'&gt;millis2 = '%.f' % (now_timestamp * 1000)print '13位毫秒级2', millis2, type(millis2)# 13位毫秒级2 1532447792615 &lt;type 'str'&gt; 三、更改str类型日期的显示格式1234567891011121314# -*- coding: utf-8 -*-import timefrom datetime import datetimetss2 = "2013-10-10 23:40:00"# 转为数组timeArray = time.strptime(tss2, "%Y-%m-%d %H:%M:%S")# 转为其它格式otherStyleTime = time.strftime("%Y/%m/%d %H:%M:%S", timeArray)print otherStyleTime # 2013/10/10 23:40:00tss3 = "2013/10/10 23:40:00"timeArray = time.strptime(tss3, "%Y/%m/%d %H:%M:%S")otherStyleTime = time.strftime("%Y-%m-%d %H:%M:%S", timeArray)print otherStyleTime # 2013-10-10 23:40:00 四、时间戳转换为指定格式的日期12345678910111213141516171819# -*- coding: utf-8 -*-import timefrom datetime import datetime# 使用timetimeStamp = 1381419600timeArray = time.localtime(timeStamp)print timeArray # time.struct_timeotherStyleTime = time.strftime("%Y--%m--%d %H:%M:%S", timeArray)print otherStyleTime # 2013--10--10 23:40:00# 使用datetimeutc_data = datetime.utcfromtimestamp(now_timestamp)print 'utc时间', utc_data, type(utc_data)# utc时间 2018-07-24 15:59:49.501000 &lt;type 'datetime.datetime'&gt;local_data = datetime.fromtimestamp(now_timestamp)print 'local时间', local_data, type(local_data)# local时间 2018-07-24 23:59:49.501000 &lt;type 'datetime.datetime'&gt; 五、时间戳转换为指定格式的日期123456789101112131415# -*- coding: utf-8 -*-import timefrom datetime import datetime# 获取当前时间戳now = int(time.time())timeArray = time.localtime(now)otherStyleTime = time.strftime("%Y--%m--%d %H:%M:%S", timeArray)print otherStyleTime # 2018--07--24 23:59:49# 获取当前时间，数组格式now = datetime.now()otherStyleTime = now.strftime("%Y--%m--%d %H:%M:%S")print otherStyleTime # 2018--07--24 23:59:49 六、获取本地时区当天0点时间戳和时间的一种方法123456789# -*- coding: utf-8 -*-import timefrom datetime import datetime# 方法1print time.mktime(datetime.now().date().timetuple()) # 1532534400.0today = datetime.today()# 方法2print datetime(today.year, today.month, today.day, 0, 0, 0) # 2018-07-26 00:00:00]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>时间</tag>
      </tags>
  </entry>
</search>
